## 자라기
* 야생학습
  * 야생 학습은 대부분 협력적이다
  * 비순차적이다
  * 자료에 한정이 없다
  * 명확한 평가가 없다
  * 정답이 없다
  * 목표가 불분명하고 바뀌기도 한다 
* 현실세계에서는 야생 학습이 더 많이 필요하다
  * 불확실성이 높은 경우 더 중요하다
* 우리나라 사람들이 공유하는 판타지
  * 고산에서 도인이 물 길어우는 것만 몇년 시킨다
  * 시키는대로 열심히 했더니 공력이 쌓인다
  * 나중에는 비급을 알려주어 득도해서 하산한다
  * 여러가지 교육적인 문제를 야기함
## 당신은 몇 년 차?
* 대다수 개발자는 소프트웨어 기술자 등급별 노임 단가에 대해 잘 알 것
* 경력으로 등급을 나눔
  * 실제로 얼마나 의미가 있을까?
* 연차는 이사람이 초급인지 아닌지 정도를 기대할 수 있다
* 연차로 결정하는 것은 편의적, 관료주의적, 조직에 손해
* 직원을 뽑을때 무엇이 그사람의 실력을 가장 잘 예측할까?
  * 연차의 상관성은 0.18, 학력의 상관성은 0.10 이었다. (약한 상관성)
  * 과제 테스트 (0.54) 아이큐 테스트 (0.51), 성실성이나 꼼꼼함 성격 테스트 (0.41, 0.31)
  * 레퍼런스체크 (0.26), 모두 연차보다 높은 상관성
  * 위 들을 결합하면 예측력이 더 높아짐
  * 연차보다 낮은것 = 필체나 나이 (-0.01)
  * 초반 몇년간의 연차의 상관성은 높다, 연차가 높아지면 상관성이 떨어진다
* 소프트웨어 개발에서 경력과 실력
  * 경험 많은 사람을 전문가로 본 연구
    * 문제를 이해하는데 더 많은 시간과 노력을 기울이는것으로 밝혀짐
    * 하지만 실력이 뛰어난 사람
      * 문제를 이해하는데 시간을 적게쓰는것으로 나옴
    * 경력과 실력을 동등하게 보는 함정에 빠지면 잘못된 전문가상을 갖는다
  * 프로그래밍 생산성 비교 연구
    * 경력이 10년인 개발자가 2년인 개발자보다 더 우수하지 않았다
  * 최소한도의 경험치만 넘어가면 경력과 상관성이 낮다
  * 경력이 직무 성과와 관련 있다는 연구
    * 단, 연차가 아닌 실제 직무 성과 (다양한 경험)
* 중요하다고 생각하는 것이 중요하지 않다
  * 대다수 조직에서 직원을 뽑는데 중요하다고 생각하는 요소가 많은 경우 중요하지 않았고, 중요하지 않다고 생각하는 요소가 중요한 경우가 많았다
    * 입사 후 성과를 통계적 분석을 해 보면 채용자도 기대와 달라 놀람
    * 경력이 성과와 상관없는것을 넘어서서 편향을 줄 수 있다
    * 최소만 넘으면 몇년 일했는지 모르는게 나을수도 있다
    * 그러면 대안은, 구조화된 인터뷰와 작업 샘플테스트, 실제 업무를 주고 테스트를 권함
* 잘 뽑는 것 이상으로 중요한 것
  * 이미 뽑은 사람을 어떻게 할 것인가
    * 많은 회사들이 소홀함
    * 전문성 관리를 개인에게 맡긴 후 저성과자 해고는 회사,개인에게 손해
  * 시스템도 중요
    * 훌룡한 사람이어도 시스템에 묻힐수 있고, 평범한 사람도 좋은 시스템에 뛰어난 성과를 낼 수도 있음
* 개발자들이 할 수 있는 것
  * 1만시간의 법칙
    * 55년 동안 걸었다고 걷는게 나아지고 있는게 아님
    * 자신의 기량을 향상시키는 목적으로 반복적으로 1만시간 수련하는것
  * 업무를 하면서도 의도적 수련을 하는 법
    * 애자일 철학 활용
      * 피드백을 짧은 주기로 얻는것, 실수를 교정할 기회가 있는 것
      * 공을 1천번 친다고 해서 늘지 않는다, 피드백을 받고 교정해야함
      * 뛰어난 의사는 진단시에 자신이 무얼 생각하는지 많은 기록, 정확한지 나중에 확인한다
* 자기계발은 복리로 돌아온다
  * 올해 인정을 받은것 같다면 1-2년 전에 자기계발을 투자 했을것
    * 반대로 올해 자기계발을 안했다면 1-2년 후에 추락 경험
  * 하루 평균 1시간도 투자하지 않는다면 직장인 하위 1/3 (통계)
  * 무서운 사실은 축적되면 엄청난 차이, 지식이나 능력은 복리로 이자가 붙는다
* 복리의 비밀
  * A작업 - 원래 그 조직지 하기로 되어 있는 일
  * B작업 - A 작업을 개선하는 일
  * C 작업 - B 작업을 개선하는 것
    * 개선하는 인프라를 설계
  * 일반적인 조직의 예 - 조직은 그대로고 결과물만 찍어냄
  * 복리조직의 예 - 조직이 첫 주기에 만든 결과물을 계단 삼아서 다음 주기에 더 높은 위치의 결과물
    * 복리 효과로 성장하게 됨, 지수적 증가
  * A,B,C 작업의 비율을 확인해봐야함
    * B나 C가 없다면 후퇴
  * A를 개선하려면 질문
    * 어떻게 하려면 더하기보다 곱하기를 할 수 있는가
    * 어떻게 해야 곱하는 비율을 높일 수 있는가
    * 이자 적용 주기를 짧게 할 수 있는가
    * 힌트
      * 자신이 이미 갖고 있는것들을 잘 활용 (새로운것보다)
        * 새로 읽는 책 보다, 읽은책으로 얼마나 활용했는지
        * 갖고있는걸 연결
        * 새로운 것들이 들어오면 기존과 충돌 시도하기
      * 외부 물질을 체화하라
        * 주기적으로 외부 자극 받기
      * 자신을 개선하는 프로세스에 대해 생각
        * 회고/반성 활동
      * 피드백 자주 받기
      * 자신의 능력을 높여준느 도구와 환경 만들기
## 학습 프레임과 실행 프레임
* 두 그룹으로 나눈 연구
  * 실행 프레임 (=점수 채점)
  * 학습 프레임 (=실험 초점, 얼마나 배우느냐)
  * 학습 프레임의 아이들이 더 많이 학습함
* 실행 프레임으로 세상을 보면, 다음 단계로 올라가냐에 대해 관심
  * 떨어지면 다른 자리를 노림, 학습은 줄어듬
* 상황때문에 학습 프레임을 갖기 어렵지 않나?
  * 누구는 같은 상황에 더 많은 학습과 성장의 기회를 찾음
## 가장 학습하기 힘든 직업이 살아남는다
* 학습에 유리한 조건, 불리한 조건
  * 알파고 시대에는 배우기 힘든 것에 집중하라
    * 목표가 분명하고 객관적으로 정해져 있고 정적인것 (알파고시대랑 지금은 다른데 ㅠㅠ)
  * 학습이 잘 일어나는 조건
    * 피드백이 주어지고 작업이 반복되며 객관적 분석이 가능한 것
    * 전문성 직업 특징이기도 함
    * 학습 속도는 인공지능은 뛰어넘음
    * 딜레마
      * 학습하기 힘든 환경에서 학습하기 힘든 주제들을 골라야 한다
  * 학습하기 힘든 환경과 주제
    * 목표가 모호하고 주관적, 동적
    * 매 순간 선택할수 있는 행동/종류 불확실
    * 목표에 근접했는지 알기 어려움
    * 주로 열린 시스템(외부 변수)
    * 과거의 선택과 결과에 대한 구조화된 기록이 없는 환경
* 컴퓨터로 대체되기 힘든일
  * 독창성, 사회적 민감성, 협상, 설득, 타인을 돕고 돌보기
  * 통계적으로 컴퓨터화 확률이 높을수록 임금이 낮았다
  * 소프트웨어 개발자와 프로그래머의 차이
    * 소프트웨어 개발자는 컴퓨터화 될 확률이 낮았다 (요구사항 설계)
    * 프로그래머는 높았다 (스펙대로 개발)
    * 즉, 개발자는 높은 수준의 협상 능력 필요
* 무엇에 집중할 것인가
  * 자신이 주로 하는 일이 시킨대로 하는거면 위험
  * 업무 상황에서 창의적으로, 사회적으로 일해야함
    * 혼자서 딱 정해진 일만 하는건 축복 아닌 저주
  * 암묵지와 직관을 잘 학습하는 사람들이 높은 경쟁력
    * 문제는 배우기 어려움, 잘 했는지 판단도 어려움
  * 어떻게 해야 하나
    * 지금이라도 암묵지와 직관을 배우고 수련하기
      * 알파고와 경쟁하기 보다 협력하는 법 배우기
