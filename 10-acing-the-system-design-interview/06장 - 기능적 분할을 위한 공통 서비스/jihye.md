# Chapter 6. 기능적 분할을 위한 공통 서비스

## 다양한 서비스의 공통 기능

- 서비스마다 다양한 비기능적 요구사항이 존재. 서로 다른 기능을 가진 서비스라도 동일한 비기능적 요구사항 공유할 수 있음
- 코드를 라이브러리에 넣어 다양한 서비스에서 사용
    - 단점: 라이브러리 업데이트는 사용자가 제어하므로 수정되지 않은 이전 버전을 계속 사용할 수 있음
- 해결책
    - API gateway
        - 공통 관심사를 중앙 집중화
        - 여러 데이터센터에 위치한 상태 비저장 서버로 구성된 경량 웹서비스
        - 다양한 조직의 많은 서비스에 공통 기능을 제공
        - 다양한 프로그래밍 언어로 작성됐더라도 가능

### 보안

- 인증 authentication - 요청이 인가된 사용자로부터 온 것인지 확인
- 인가 authorization - 요청을 할 수 있는 권한이 있는지 체크
- SSL종료 - 로드밸런서에서는 비용이 많이 들기 때문에  api gateway에서 수행
- 서버사이드 데이터 암호화

### 오류 검사

- 잘못되거나 중복 요청이 서비스 호스트에 도달하는 것을 방지. 유효한 요청만 처리하도록 함
    - 요청 유효성 검사
    - 요청 중복 제거

### 성능과 가용성

- 캐싱
    - api gateway는 데이터베이스나 다른 일반적인 요청을 캐시할 수 있음
    - 인증, 권한부여 서비스 호출을 줄이기 위해 사용자 식별 정보를 활용함
- 속도 제한 rate limit, throttling
    - 요청으로 인해 서비스가 과부하되는 것을 방지
- 요청 dispatching
    - 다른 서비스에 원격 호출.
    - 한 서비스가 속도 저하 되더라도 다른 서비스의 요청은 영향을 받지 않음
        - 벌크해드, 서킷브레이커
            
            리소스 격리를 구현하고 원격 호출이 실패할 때 서비스를 더 탄력적으로 만듬
            
- 로깅과 분석
    - 요청 로깅이나 사용자 데이터 수집

### 서비스 매쉬/사이드카 패턴

- 그림 6.1
- 서비스가 작동중이라도 사이드카를 사용할 수 없으면 서비스의 호스트를 사용할 수 없다는 단점
→ 일반적으로 단일 호스트에서 여러 서비스나 컨테이너를 실행하지 않는 이유
- 관리자는 제어 플레인을 사용해 프록시를 관리, 외부 서비스와 인터페이스 할 수 있다.

### metadata service

- 시스템 내 여러 구성 요소가 사용하는 정보를 저장
- 전체 데이터를 직접 넘기기보다 ID를 전달
- ID를 받으면 해당 ID에 대응하는 정보를 요청
- 예: ETL pipeline
- 그림 6.2
- 메타데이터 트레이드 오프
    - 복잡성, 전반적인 지연시간의 증가
    - 발행자 클러스터가 트래픽 급증을 경험하면 메타데이터 서비스에 높은 비율의 읽기 요청을 하게 되므로
    - 메타데이터는 높은 읽기 볼륨을 지원할 수 있어야 함.
    - → 메타데이터 서비스는 ID조회를 위한 것
- 그림 6.3

### 서비스 디스커버리

- microservice의 개념
- 클라이언트가 사용 가능한 서비스 호스트를 식별하는 방법
- 내부적으로 수행 엔지니어는 알 필요 없음
- 서비스 레지스트리: 서비스의 사용 가능한 호스트를 추적하는 데이터베이스

## 기능적 분할과 다양한 프레임워크

### 앱

### 웹서버 앱의 목적

- 웹 브라우저를 사용하는 누군가가 google.com에 접근하면 브라우저는 node.js 앱에서 브라우저 앱을 다운로드 한다 (경량)
- 특정 url 요청을 할 때 node.js는 url의 라우팅을 처리하고 해당 페이지 제공
- 특별한 요청이나 양식작성, 제출, 버튼 클릭등에 백엔드 요청
- 그림 6.4
- 브라우저가 백앤드에 직접 요청하지 않는 이유는
    - 백앤드가 REST app이라면 그 api endpoint가 그 브라우저가 필요로 하는 정확한 데이터를 반환하지 않을 수 있음
    - 데이터 전송은 필요 이상의 데이터를 가져와야 할 수도 잇는데 이는 인터넷을 통해 사용자의 기기와 데이터센터 사이에서 발생하며 node js앱이 대규모 요청에 더 효율적.
        - 같은 데이터센터 내 인접한 호스트 간에 일어날 가능성이 높기 떄문
- GraphQL 앱은 사용자가 필요한 데이터를 정확히 요청할 수 있지만 endpoint 보호에는 rest 보다 더많은 작업이 필요해 개발시간이 길어지고 보안 취약점 발생할 수 있다.

### 웹과 모바일 프레임워크

- 브라우저 앱 개발
    - 브라우저는 html, css, javascript만을 인식
    - 브라우저는 사용자 기기에 설치되므로 사용자 스스로 업그레이드 해야 됨
    - 가장 인기있는 브라우저 앱: react, vue js angular js
    - 그외 메테오, jQuery, Ember.js Backbone.js
    - 타입스크립트는 정적 타입 언어. 자바스크립트를 감싸는 상위 집합
    - 브라우저/클라이언트 사이드를 위한 것
    - 서버사이드 프레임워크
        - express
        - deno
        - goji
        - Rocket
        - Vapor
        - Vert.x
        - PHP
- 모바일 앱 개발
    - 안드로이드, ios
    - 네이티브 플랫폼
        - 구글, 애플이 자체 앱 개발 플랫폼을 제공
- 크로스 플랫폼 개발
    - 이론상 동일한 코드를 여러 플랫폼에서 실행시킴.
        - 리액트 네이티브
        - 플러터
        - ionic
        - xamarin
        - electron
        - cordova
- 백앤드 개발: RPC, REST, GraphQL로 분류할 수 있음
    - gRPC
    - 쓰리프트 & protocol buffer: 데이터를 직렬화 하여 네트워크 트래픽을 줄이는 데 사용
    - Dropwizard: java rest framework
    - Flask, Django: python rest framework
- 풀스텍 프레임워크
    - Dart: 모든 솔루션을 위한 프레임워크를 제공하는 언어
    - 레일스: rest에도 사용할 수 있는 루비 풀스텍 프레임워크
    - Yesod: REST에만 사용할 수 있는 하스켈 프레임워크
    - 통합 하스켈 플랫폼: 또다른 하스켈 프레임워크
    - Phoenix: 엘릭서 언어를 위한 프레임워크
    - JavaFX: 데스크톱, 모바일, 임베디드 시스템을 위한 자바 client application platform
    - Beego: Golang 프레임워크

### 라이브러리와 서비스

| 라이브러리 | 서비스 |
| --- | --- |
| 사용자가 사용할 버전/빌드를 선택 | 개발자가 빌드를 선택하고 업그레이드할 시기 제어 |
| 예측 가능한 지연시간, 재현 가능한 동작 | 기술에 구애받지 않음. |
|  | 독립적으로 확장 가능 |
|  | 네트워크 상태에 따라 지연시간 예측이 덜 가능, |
| 사용자에게 코드가 노출 | 코드를 사용자에게 노출하지 않음 |

### 일반적인 API 패러다임

- REST
- gRPC
    - 원격 프로시저 호출
    - 프로그래머가 네트워크 세부 사항을 처리하지 않고도 다른 호스트에서 프로시저를 실행하게 하는 기술
- GraphQL
    - 클라이언트가 API에서 필요한 데이터를 명확히 지정할 수 있도록 하는 선언적 쿼리 언어
    - API데이터 쿼리와 조작 언어를 제공
    - 보안 메커니즘을 포함 러닝 커브가 높음
    
- 웹소켓
    - 지속적인 TCP 연결을 통해 전이중 통신을 가능하게 하는 통신 프로토콜