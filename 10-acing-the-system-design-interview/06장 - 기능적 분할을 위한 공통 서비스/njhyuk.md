# 6장: 기능적 분할을 위한 공통 서비스
## 6.1 다양한 서비스의 공통 기능
* 서비스마다 다양한 비기능적 요구사항이 존재할 수 있음
* 라이브러리에 넣어 다양한 서비스에서 사용할 수 있음
  * 라이브러리 업데이트는 사용자가 제어하므로 서비스는 새 버전에서 수정된 버그나 보안문제가 있는 이전 버전을 계속 실행할 수 있음
* API 게이트웨이로 이러한 공통 관심사를 중앙 집중화 할 수 있음
* 다음은 API 게이트웨이 기능 소개
### 6.1.1 보안
* 인증
* 인가
* SSL 종료
* 서버사이드 데이터 암호화
### 6.1.2 오류 검사
* 요청 유효성 검사
* 요청 중복 제거
### 6.1.3 성능과 가용성
* 캐싱
* 속도 제한
* 요청 디스패칭
### 6.1.4 로깅과 분석
* 로깅, 사용데이터 수집, 분석, 감사
## 6.2 서비스 메시/사이드카 패턴
* API 게이트웨이의 단점을 해결하기 위한 서비스 메시
* 사이드카의 작은 단점
  * 서비스가 작동중이더라도 사이드카르 사용할 수 없으면 서비스 사용 불가
* 서비스메시
  * 관리자는 제어 플레인을 사용해 프록시를 관리하고 외부 서비스와 인터페이스 할 수 있음
  * 속도 제한은 서비스 메시로 관리 가능
## 6.3 메타데이터 서비스
* 시스템 내의 여러 구성요소가 사용하는 정보 저장
  * 구성요소들이 서로 정보를 전달할때 전체 데이터 대신 ID만 전달하게 가능
* 메타데이터의 트레이드오프
  * 복잡성과 지연시간 증가
## 6.4 서비스 디스커버리
* 클라이언트가 사용 가능한 서비스 호스트를 식별하는 방법
## 6.5 기능적 분할과 다양한 프레임워크
### 6.5.1 앱의 기본 시스템 설계
백엔드 서비스에 요청하는 iOS앱/AOS앱/브라우저앱을 가지는 기본 구조
### 6.5.2 웹서버 앱의 목적
* 브라우저가 백엔드에 직접 요청하지 않는 이유
  * 백엔드가 REST 앱이라면 그 API 엔드포인트가 화면에 필요한 모든 데이터를 반환하지 않을 수 있음
    * 여러 API 요청을 필요할 수 있음
  * Node.JS 앱에서 BFF 처리
### 6.5.3 웹과 모바일 프레임워크
* 브라우저 앱 개발
  * React
  * Vue.JS
  * Angular
* 모바일 앱 개발
  * 안드로이드
  * iOS
* 크로스 플랫폼 개발
  * 리액트 네이티브
  * 플러터
  * 일렉트론
  * PWA
* 백엔드 개발
  * gRPC
  * 쓰리프트
  * Flask
  * 레일즈
## 6.6 라이브러리와 서비스
시스템 구성요소를 라이브러리 vs 서비스로 구현하는 것의 장단점을 논의 할 수 잇음
### 6.6.1 언어 특정적 vs 기술에 구애받지 않음
* 라이브러리는 클라이언트 언어 특정적
  * 단일 언어일때 최적으로 구현
  * 동일한 로직을 여러 언어로 재작성 해야할 수 있음
### 6.6.2 지연 시간의 예측 가능성
라이브러리는 네트워크 지연이 없음, 서비스는 제어할 수 없음
### 6.6.3 동작의 예측 가능성과 재현성
서비스는 다음과 같은 더 많은 의존성으로 인해 덜 예측 가능함
* 배포 롤아웃은 점진적
* 요청 사이에 서비스 개발자에 의해 변경될 수 있음
* 서비스는 다른 서비스에 요청을 보냄
디버깅은 종종 서비스가 더 쉽다
* 라이브러리는 클라이언트의 오류 로그를 못봄
### 6.6.4 라이브러리의 확장성 고려사항
라이브러리는 독립적으로 확장할 수 없다, 서비스는 확장 가능
### 6.6.5 기타 고려사항
* 라이브러리를 사용하는건 주저되지만, 서비스 API 붙이는건 개방적
* 라이브러리는 빌드 크기 증가, 악성코드 우려
* 라이브러리는 주요 변경이 일어날걸로 예상하지만, 서비스는 주요 변경에 덜 관대하다
## 6.7 일반적인 API 패러다임
### 6.7.1 개방형 시스템 상호 연결 모델
* 7 계층 OSI 모델은 네트워크 시스템의 기능을 특징 짓는 개념적 프레임워크/모델
* GraphQL, REST, 웹소켓은 HTTP 위에 구현해서 7번 계층
* RPC HTTP와 같은 상위 수준 프로토콜에 의존하지 않고 연결/포트/세션 직접 처리해서 5번 계층
### 6.7.2 REST
* 하이퍼미디어
  * 하이퍼미디어 제어 (HATEOAS)
    * 다음에 가능한 작업의 정보를 클라이언트에 제공
    * 응답 JSON 내의 links 와 같은 필드 형태로, 클라이언트가 논리적으로 다음에 쿼리할 API 엔드포인트 제공
* 캐싱
  * 개발자는 가능하면 항상 REST 리소스를 캐시 가능하게 선언해야 함
  * 헤더
    * Expires : 캐시된 리소스의 절대 만료 시간
    * Cache-Control : 응답을 N초동안 캐시할 수 있다고 내려줌
    * ETAG : GET 요청에 ETAG 값을 포함, 서버에서 ETAG가 다를때만 리소스값 반환
    * Last-Modified : 리소스가 마지막으로 수정된 날짜
* REST의 단점
  * 하이퍼미디어나 OPTIONS 엔드포인트 외에 통합된 문서화 메커니즘이 없다
    * 따로 OpenAPI 문서화 프레임워크를 추가해야 한다
  * 표준화된 버전 관리 절차가 없다
    * /v2 /v3 를 붙이는 관행이 있다
* RPC
  * RPC는 저전력 기기에 가장 적합한 통신 아키텍처
  * 프로토콜 버퍼는 효율적 인코딩 방식, JSON은 무거움
  * 파일에 엔드포인트의 스키마를 정의하는게 필수 단계, 클라이언트는 항상 좋은 API 문서를 갖게됨
### 6.7.4 GraphQL
* 클라이언트가 원하는 데이터와 그 형식을 결정
* 각 API 사용자가 다른 쿼리 수행, 사용자 분석이 복잡함
* 데이터베이스를 노출하고 클라이언트가 SQL 쿼리를 수행하게 허용되어 주의 필요
### 6.7.5 웹소켓
* 지속적인 TCP 연결을 통해 양방향 통신을 가능하게 함
* 웹소켓 연결을 열린 상태로 유지해야함
  * REST와 비요할때 Stateful 함
* 웹소켓의 상태 저장 특성, 연결 유지 오버헤드
  * 확장성이 낮음
### 6.7.6 비교
* REST와 RPC가 일반적
* 스타트업은 REST를 사용해 단순화, 대규모 조직은 RPC의 효율성과 이전/이후 버전 호환성의 이점을 얻을 수 있음

