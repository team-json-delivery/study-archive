# 6 기능적 분할을 위한 공통서비스
- API 게이트웨이 설명, 서비스 메시라고 하는 사이드카 패턴 설명
- 공통 데이터를 메타데이터 서비스로 중앙 집중화 하는 방법 설명 -> 공유 공통 서비스로 분할 가능
- 시스템 설계의 다양한 구성 요소를 개발하는데 사용할 수 있는 프레임워크 설명
### 6.1 다양한 서비스의 공통 기능
- API 게이트웨이는 공통 관심사를 중앙 집중화
  - 공통 관심사를 파편화 했을때 이슈는 코드 중복, 불필요한 리소스 사용, 오류나 비효율성 발생 가능성 높음
  - 여러 데이터 센터에 위치한 상태 비저장 서버
  - 솔루션으로 아마존 API 게이트웨이, 콩(Kong)
##### 6.1.1 보안
- 무단 접근 방지
  - 인증: 요청이 인가된 사용자 확인
  - 인가: 권한 확인
  - SSL 종료: 로드 밸랜서의 종료는 비용이 많이 들기에, 게이트웨이에서 종료
  - 서버 사이드 데이터 암호화: 저장 전 데이터 암호화, 요청자에게 전달 전 복호화
##### 6.1.2 오류 검사
- 요청 유효성 검사: 요청이 제대로 형식화 되었는지 확인
- 요청 중복 제거: 중복을 파하기 위해 캐생을 사용해 이전 본 요청 ID를 저장
##### 6.1.3 성능과 가용성
- 캐싱, 속도 제한, 요청 디스패칭 제공 -> 서비스의 성능과 가용성 개선
  - 캐싱: 데이터베이스나 다른 서비스의 일반적인 요청을 캐시
    - 엔티티 정보 캐시
    - 인증과 권한 부여 서비스 호출을 줄이기 위해 사용자 식별 정보 활용
  - 속도 제한(Rate Limit, 스로틀링): 서비스가 과부하되는 것을 방지
  - 요청 디스패칭: 적걸한 목적지로 효율적으로 할당 분배 -> 리소스 격리
##### 6.1.4 로깅과 분석
- 요청 로깅
- 사용 데이터 수집 -> 분석, 감사, 청구, 디버깅등 목적으로 실시간 정보 수집

### 6.2 서비스 메시/사이드카 패턴
- API 게이트웨이 단점을 해결하기 위해 서비스 메시 사용
  - 추가 서비스를 통해 요청을 라우팅 해야하므로 요청에 추가 지연 발생
  - 대규모 클러스터로 비용 제어 하기 위해 확장 필요
- 작은 단점
  - 사이드카를 사용할 수 없으면 서비스의 호스트 사용 불가능
- 서비스 메시는 컨트롤 플레인과 데이터 플레인, 관찰 가능성 플레인 구성
  - 컨트롤 플레인
    - 프록시를 관리하고 외부 서비스와 인터페이스할 수 있음
  - 관찰 가능성 플레인
    - 로깅, 모니터링, 경보, 감사 제겅
- 속도 제한은 서비스 메시로 관리할 수 있는 또 다른 공통 공유 서비스 예
### 6.3 메타데이터 서비스
- 시스템 내의 여러 구성 요소가 사용하는 정보를 저장 -> 서비스와는 ID를 통해 조회
- 타 서비스에서 파일 시스템과 같은 대용량 정보를 중복으로 주고 받지 않게 지원
- 트레이드 오프 관계는 복잡성과 전반적인 지연 시간의 증가
  - 발행자는 메타 데이터 서비스와 큐(메타데이터 ID 포함)에 모두 쓰기를 해야함
  - 발행자 클러스터가 트래픽 급증하면 메타데이터 서비스의 높은 비율의 읽기 요청하므로 높은 읽기 볼륨을 지원 가능해야함
- 메타데이터 서비스는 ID 조회를 위한 것
### 6.4 서비스 디스커버리
- 각 내부 API 서비스의 일반적으로 접근할 수 있는 포트 번호가 할당된다는 것만 알면 됨
- 외부 API 서비스와 대부분의 UI 서비스에는 접근할 수 있는 URL이 할당됨
- 클라이언트가 사용 가능한 서비스 호스트를 식별하는 방법
### 6.5 기능적 분할과 다양한 프레임워크
- 여러 프레임워크와 언어에 관해 인식을 제공
##### 6.5.1 앱의 기본 시스템 설계
- 백엔드 서비스에 요청하는 모바일 앱을 개발하는 회사는 IOS, AOS 갖게 됨
- 또는 모바일 앱과 동일한 기능을 가진 브라우저 앱을 개발하거나 모바일 다운로드를 유도
- 다음 질문을 먼저 설명한 후 다양한 프레임워크와 프로그래밍 언어 설명을 확장
  - 백엔드와 브라우저 앱에서 별도의 웹 서버 애플리케이션이 있는 이유는?
  - 브라우저 앱이 nods.js앱에 요청을 하고, 이 앱이 다시 AOS와 IOS 앱과 공유하는 백엔드 요청을 하는 이유는?
##### 6.5.2 웹 서버 앱의 목적
- 브라우저가 백엔드에 직접 요청하지 않는 이유는 무엇인가? 브라우저가 필요하는 데이터를 정확히 반환하지 않을 수도
  - 하나의 서비스 외 추가적인 데이터가 필요하면 브라우저에서 다중 호출 필요 -> 불필요
- GraphQL은 필요한 데이터를 정확히 요청할 수 있지만, 개발시간이 길어지고 보안취약점에 약함
  - 유연한 쿼리는 성능 최적화에 더 많은 작업이 필요함
  - 클라이언트에 더 많은 코드가 필요
  - 스키마를 정의 하기 위해 더 많은 작업이 필요
  - 요청이 더 커짐
##### 6.5.3 웹과 모바일 프레임워크
- 브라우저 앱개발
  - 브라우저 앱 프레임워크는 브라우저/클라이언트 사이드를 위한 것
- 모바일 앱개발
  - AOS, IOS가 존재하며, 네이티브 플랫폼이라고 지칭함
- 크로스 플랫폼 개발
  - 여러 플랫폼에서 동일한 코드를 실행함으로써 중복 작업을 줄임
- 백엔드 개발
  - 백엔드 프레임워크는 RPC, REST, GraphQL로 분류 가능
### 6.6 라이브러리와 서비스
- 라이브러리와 서비스 사용 사이의 명확한 선택은 없으므로 두 옵션에 대해 트레이이드오프 관계 설명 가능해야함
  - 라이브러리는 독립적인 코드 묶음 또는 요청 응답을 전달하는 중간층일 수 있음

| 라이브러리                          | 서비스                      |
|--------------------------------|--------------------------|
| 사용자가 버전/빌드 선택 및 업그레이드 선택       | 개발자가 빌드 선택 및 업그레이드 시기 제어 |
| 사용자가 버그나 보안 문제가 있는 라이브러 사용 가능성 |                          |
| 최신 버전을 항상 사용하고자 업그레이드를 직접 구현   |                          |
| 기기 간 통신 없이 제한                  | 여러 호스트간 데이터 요청 가능        |
| 언어 특정적                         | 기술에 구애 받지 않음             |
| 예측 가능한 지연 시간                   | 네트워크 이슈 등으로 인한 불예측       |
| 예측 가능하고 재현 가능한 동작              | 예측 불가능                   |
| 라이브러리 부하 확장 시, 사용자 부담          | 독립적 확장 가능                |
| 역컴파일을 통한 지적재산 취약               | 코드가 사용자에게 노출되지 않음        |
##### 6.6.1 언어 특정적 vs. 기술에 구애받지 않음
- 라이브러리는 일반적으로 특정 언어로 구현되어 있음
- 서비스는 기술에 구애를 받지 않음
##### 6.6.2 지연 시간의 예측 가능성
- 라이브러리는 네트워크 지연이 없고, 쉽게 프로파일링 가능
- 서비스는 예측할 수 없고, 지연시간 제어 불가능
##### 6.6.3 동작의 예측 가능성과 재현성
- 서비스는 더 많은 의존성으로 인해 덜 예측 가능하고 재현 가능한 동작
  - 배포 롤아웃은 보통 점진적으로 진행
  - 사용자는 서비스의 데이터를 완전 제어 불가능 -> 요청 사이에 서비스가 변경될 수 있음
  - 서비스의 예측할 수 없고 재현할 수 없는 동작에 영향을 받음
- 종종 라이브러리보다 디버깅이 쉬움
  - 서비스 개발자는 로그 접근 가능, 라이브러리 개발자는 사용자 기기 접근이 안됨
  - 서비스 개발자는 환경 제어 및 도구 설정 가능, 라이브러리는 다양한 환경에서 실행
##### 6.6.4 라이브러리의 확장성 고려사항
- 라이브러리는 사용자 APP 내 포함되어 있어 독립적으로 확장 불가능 -> 단일 사용자 의미 없음
- 라이브러리만 확장하려면 해당 라이브러리를 감싸는 자체 서비스를 만들어 확장 가능 -> 더이상 라이브러리가 아닌 사용자가 소유한 서비스
##### 6.6.5 기타 고려사항
- 자신의 코드를 라이브러리리와 번들링 하는 것에 주저하지만, 서비스 연결은 개방적
- 어댑터 패턴은 서비스보다 라이브러리를 사용할 때 더 자주 사용됨
### 6.7 일반적인 API 패러다임
- 통신 패러다임이 존재 -> 서비스 패러타임을 선택할때 트레이드 오프 관계 고려 필요
  - Rest
  - RPC
  - GraphQL
  - 웹소켓
##### 6.7.1 개발형 시스템 상호 연결(OSI) 모델
- 기본 내부 구조와 기술에 관계 없이 네트워킹 시스템의 기능을 특정 짓는 개념적 프레임워크/모델
  - 액터, GraphQL, Rest, 웹소켓은 HTTP 위에 구현됨
  - RPC는 HTTP와 같은 상위 수준 프로토콜에 의존하지 않고 연결, 포트 세션을 직접처리하므로 5번 계층으로 분류

| 계층번호 | 이름     | 설명                    | 예시                       |
|------|--------|-----------------------|--------------------------|
| 7    | 응용     | 사용자 인터페이스             | FTP, HTTP, 텔넷            |
| 6    | 표현     | 데이터 표현 및 암호화          | UTF, ASCILL, JPEG, MPEG  |
| 5    | 세션     | 연결 유지, 포트와 세션을 제어     | RPC, SQL, NFX            |
| 4    | 전송     | 종단간 연결, 전송과 흐름 정의     | TCP, UDP                 |
| 3    | 네트워크   | 논리 주소 시정, 물리 경로 정의    | IP, ICMP                 |
| 2    | 데이터 링크 | 네트워크 형식, 물리 계층의 오류 정정 | 이더넷, 와이파이                |
| 1    | 물리     | 물리적 매체를 통해 원시 비트      | 광섬유ㅡ 동축 케이블, 리피터 모뎀, USB |

##### 6.7.2 REST
- 배우기 쉬우며 설정, 실허므 디버깅 또한 간단
- 하이버피디어와 캐싱 기능 존재
  - RPC나 GraphQL 같은 다른 통신 아키텍처는 하이퍼미디어를 제공하지 않음
  - Expires, Cache-Control 등 헤더를 사용
- 단점
  - 하이퍼미디어나 OPTIONS 엔드포인트 외에 통합된 문서화 메커니즘이 없음 -> 개발자가 따로 제공하지 않으면 사용자가 알기 힘듬
##### 6.7.3 RPC(원격 프로시저 호출)
- 네트워크 세부 사항을 처리하지 않고도 다른 주소 공간이나 다른 호스트에서 프로시저를 실행하게 하는 기술
  - GRPC, 쓰리프트, RPyc가 존재
- RPC 프레임워크가 REST보다 나은 주요 장점
  - 리소스 최적화를 취해 설계되어 저전력 기기에 가장 적합
  - 프로토콜 버퍼 효율 인코딩 방식 -> 트래픽 감소가 두드러짐
  - 파일에 엔드포인트의 스키마를 정의 -> 이전/이후 버전에 대한 호환성 유지
- 단점
  - 바이너리 프로토콜이라는 특정 비롯 -> 모니터링 힘듬
##### 6.7.4 GraphQL
- API에서 필요한 데이터를 명확히 지정할 수 있도록 하는 선언적 쿼리
  - 서버는 효율적이며 클라이언트가 요청한 것을 정확하게 제공
- 단점
  - 간단한 API에는 너무 복잡할 수 있음
  - RPC와 REST 보다 학습 곡선이 높으며, 보안 메커니즘도 포함
  - 사용자 커뮤니티가 작음
  - JSON으로만 인코딩 돼 JSON의 모든 트레이드 오프 관계를 가짐
  - 각 API 사용자가 다른 쿼리를 수행하므로 사용자 분석이 더 복잡해줄 수 있음 -> 엔드포인트 덜명확
  - 데이터 베이스를 노출하고 SQL를 수행하게 허용하는 것과 유사
- 기능 표준 구현과 문서화를 제공하므로 복잡한 요구사항을 해결하는데 REST보다 편함
##### 6.7.5 웹소켓
- 지속적인 TCP 연결을 통해 전이중 통신을 가능하게 하는 통신 프로토콜
  - REST, RPC, GraphQL은 설계 방식 또는 개념 <-> 웹소켓과 HTTP는 통신 프로토콜
- 초기 연결 생성하는데 HTTP 핸드쉐이크 사용 후 서버에 HTTP에서 웹소켓으로 업그레이드 요청 처리 및 지속적인 TCP 연결
- 연결을 열린 상태로 유지해 모든 참여자의 오버헤드를 증가 시킴 -> 확장성이 낮음
  - 요청은 관리 상태/연결이 포함된 호스트에서 처리
- 확장성이 낮은 지연시간과 높은 성능과 교환
##### 6.7.6 비교
- 아키텍처 스타일간 트레이드 오프 관계와 스타일 고려
  - REST와 RPC가  가장 일반적임 -> 스타트업은 REST, 대규모 조직은 RPC
