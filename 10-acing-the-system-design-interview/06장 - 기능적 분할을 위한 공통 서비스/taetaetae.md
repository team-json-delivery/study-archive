## 06. 기능적 분할을 위한 공통 서비스
#### 6.1 다양한 서비스의 공통 기능
- API GW
  - 여러 데이터 센터에 위치한 상태 비저장 서버로 구성된 경량 웹 서비스
  - 공통 관심사를 중앙에서 관리, 공통 기능 제공
- 보안
  - 인증(Authentication) 과 인가(Authorization)
  - SSL 종료
  - 서버사이드 데이터 암호화
- 오류 검사
  - 요청 유효성 검사 : 공통 인터페이스 점검
  - 요청 중복 제거 : 중복을 피하기 위해 캐싱을 사용해 이전에 본 요청을 저장
- 성능과 가용성
  - 캐싱
  - 속도 제한(Rate Limiting)과 스로틀링(Throttling)
  - 요청 디스패칭 : 효율적으로 할당 하고 분배
- 로깅과 분석

#### 6.2 서비스 메시/사이드카 패턴
- API GW의 단점(추가 서비스를 통해 라우팅해야 하므로 각 요청에 추가 지연 발생, 확장 필요)을 해결하기 위한 서비스 메시 사용
- 데이터 플레인: 실제 트래픽을 처리하는 사이드카 프록시
- 컨트롤 플레인: 설정, 정책, 라우팅 규칙을 중앙에서 제어하는 관리자

#### 6.3 메타데이터 서비스
- ID만 전달하여 관리. SQL 정규화와 유사하게 시스템 내 중복 정보가 줄어들어 일관성 향상
- 메타 데이터 서비스 사용의 트레이드 오프 : 복잡성과 지연 시간의 증가

#### 6.4 서비스 디스커버리 
- 내가 호출하려는 서비스의 주소(IP:Port)를 자동으로 찾는 기능
- Eureka, Consul, Kubernetes DNS	

#### 6.5 기능적 분할과 다양한 프레임워크
- 앱의 기본 시스템 설계
  - iOS, 안드로이드
- 웹 서버 앱의 목적
  - 브라우저에서의 접근
- 웹과 모바일 프레임워크
  - 브라우저 앱 : HTML, CSS, 자바스크립트
  - 모바일 앱 개발 : iOS, 안드로이드
  - 크로스 플랫폼 개발 : 플러터, 리액티브 네이티브, ionic
- 백엔드 개발 : REST, RPC, GraphQL
- 풀스택

#### 6.6 라이브러리와 서비스
- 언어 특정적 vs 기술에 구애받지 않음
  - 라이브러리는 클라이언트의 언어로 돼 있어야 함
  - 반면 서비스는 기술에 구애받지 않음
- 지연 시간의 예측 가능성
  - 라이브러리는 네트워크 지연이 없고 예측 가능한 응답시간, 프로파일링 쉬움
  - 서비스는 그 반대(네트워크 지연)
- 동작의 예측 가능성과 재현성
  - 서비스가 라이브러리 보다 덜 예측 가능 (더 많은 의존성)
  - 서비스가 디버깅에 쉬움
- 라이브러리의 확장성 고려사항
  - 클라이언트에 포함되어 있으므로 독립적 확장 어려움
  - 확장 비용은 클라이언트가 부담

#### 6.7 일반적인 API 패러다임
- 개방형 시스템 상호 연결(OSI) 모델
  - 응용 / 표현 / 세션 / 전송 / 네트워크 / 데이터 / 물리
- REST
  - 하이퍼미디어(HATEOAS)와 캐싱
  - 통합된 문서화 메커니즘이 없음(+관행)
- RPC
  - 구글의 gRPC, 페이스북의 쓰리프트
  - 네트워크 세부사항을 직접 처리하지 않음
  - REST보다 속도가 빠름(인코딩), 스키마 문서화 필수
  - 바이너이 프로토콜이라 클라이언트가 업데이트 해야하는 단점
- GraphQL
  - 클라이언트가 필요한 데이터를 지정하는 선언적 쿼리 언어
  - 간단한건 오히려 복잡할수 있음
- 웹소켓
  - 지속적인 TCP연결
  - 연결을 연린 상태로 유지해 모든 참여자의 오버헤드를 증가시킴
  - P2P 통신 허용, 백엔드 불필요
  - 확장성이 낮지만 낮은 지연시간과 높은 성능