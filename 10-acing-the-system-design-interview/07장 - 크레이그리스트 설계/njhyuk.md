# 7장 : 크레이그리스트 설계
## 7.1 사용자 스토리와 요구사항
* 게시자
  * 게시자는 게시물을 작성 및 삭제할 수 있음
  * 자신의 게시물을 검색할 수 있음
  * 다음의 정보를 포함함
    * 제목, 설명, 가격, 위치, 10장의 사진, 동영상
  * 게시자는 7일마다 게시물을 갱신할 수 있음, 갱신가능한 이메일 알림을 받게됨
* 조회자
  * 지난7일동안 특정 도시에서 작성된 모든 게시물을 보거나 검색함, 무한스크롤
  * 결과에 필터를 적용함
  * 개별 게시물을 클릭해 세부 정보를 봄
  * 이메일 등으로 게시자에게 연락함
  * 게시물을 신고함
* 비기능적 요구사항
  * 확장성 : 단일 도시에서 최대 천만명 수용
  * 가용성 : 99.9% 가용시간
  * 성능 : 조회자가 게시물 작성 후 몇초 내에 볼 수 있어야함, 검색/게시물조회 P99 1초
  * 보안 : 게시자는 게시물을 작성하기 전 로그인 해야함
* 사용자에게 해당 지역의 게시물만 표시할 수 있음
* 게시물은 자동이 아닌 수동으로 생성되므로 스토리지 증가 속도가 느림
* 자동으로 생성되는 데이터는 처리하지 않음
* 게시물은 1주일 후 자동으로 삭제될 수 있음
## 7.2 API
* 게시물
  * GET/DELTE /post/{id}
  * GET /post?search={keword}
  * POST/PUT /post
  * POST /contact
  * POST /report
  * DELTE /old_posts
* 사용자 관리
  * POST /signup
  * POST /login
  * DELETE /user
## 7.3 SQL 데이터베이스 스키마
* USER : id, firstname, lastname, signup_at
* post: id, created_at, poster_id, location_id, title, description, pirce, condition, country_code, state, city, strett_number, street_name, zip_code, phone_number, email
* images: id, post_id, image_address
* report : id, post_id, user_id, abuse_type, messsage
* 이미지 저장 : 객체 스토리지 (S3)
* image_address: 이미지 검색 식별자
## 7.4 초기 고수준 아키텍처
* 사용자 인증 서비스와 게시물 객체 스토리지를 사용하는 모놀리스
* 클라이언트 프론트, 백엔드, SQL 서비스, 객체 스토리지, 사용자 인증 서비스
## 7.5 모놀리스 아키텍처
* 모놀리스 제안 설계는 직관적이지 않음, 사용될 가능성 낮음, 면접관이 놀랄 수 있다
* 모든 설계 결정이 트레이드 오프, 이러한 설계를 제안하고 트레이드 오프 설명
## 7.6 SQL 데이터베이스와 객체 스토리지 사용
* 이미지를 SQL에 넣는 방법도 고려될 수 있음
* 이는 클라이언트 호스트가 백엔드 호스트를 통해 이미지를 다운받아야함
  * 백엔드에 부담, 이미지 다운로드 지연시간 증가, 다운로드 실패 가능성
* 초기 구현을 단순하게 유지하고 싶으면 사용, 추후 객체 스토리지 사용
## 7.7 마이그레이션은 번거롭다
* SQL에 이미지를 저장하면, S3로 옮기는게 까다롭다
* 개발자의 노트북에서 실행되 한스토리지에서 레코드를 읽고 다른스토리지에 쓰는 파이썬 스크립트를 작성할 수 있다
* 스크립트는 체크포인팅을 수행해야 하므로, 간단한 체크포인팅 매커니즘이 필요하다 (로컬에 ID저장)
* 데이터 마이그레이션은 복잡하고 비용이 많이 드는 작업이므로 가능하면 피해야 한다
## 7.8 게시물 작성과 읽기
* 클라이언트에서 처리
  * 클라이언트는 이미지를 제외한 백엔드에 POST 요청 
  * 클라이언트는 이미지 파일을 객체 스토리지에 업로드
  * 이 접근법은 백엔드는 이미지 파일 업로드가 성공했는지 알 수 없음
* 서버에서 처리
  * 백엔드는 모든 이미지 파일이 객체 스토리이제 성공적으로 업로드 된 후에 200 반환
* 트레이드오프
  * 백엔드 제외
    * 적은 리소스
    * 지연시간 감소
  * 백엔드 포함
    * 객체스토리지에 인증과 권한 부여 매커니즘 구현 필요 없음
    * 객체스토리지가 외부에 노출되지 않음
    * 조회자가 게시물의 모든 이미지를 볼 수 있음이 보장됨
## 7.9 기능적 분할
* 확장의 첫 단계는 지역별로 기능적 분할 (지리적 위치 라우팅)
* 각 도시에 서브도메인을 할당해 지리적 분할을 수행한다
* 브라우저에 craiglist.org 에 접속하면
  * ISP 가 DNS 조회를 수행하고 IP 주소 반환
  * 브라우저가 IP 주소로 요청을 보냄, 서버는 이 IP 주소를 기반으로 사용자 위치 파악
    * 서브도메인이 포함된 3xx 응답 반환
  * 이 서브도메인의 IP 주소를 얻기 위해 다른 DNS 조회 필요
  * 브라우저가 서브도메인의 IP 주소로 요청을 보냄
## 7.10 캐싱
* 특정 게시물이 매우 인기있고 높은 조회수를 기록하는 경우
  * 인기있는 게시물을 캐싱
* 레디스를 사용해 LRU 캐시 구현
## 7.11 CDN
* CDN 사용 고려해볼 수 있음
* CSS와 자바스크립트 파일을 브라우저 캐싱할 수 있음
## 7.12 SQL 클러스터로 읽기 확장
읽기 작업의 확장이 필요하다면 SQL 복제
## 7.13 쓰기 처리량 확장
* ExecuteNonQuery 는 초당 수천건의 INSERT 수행
* 배치 커밋을 사용해서 각 INSERT 문 로그 플러시 오버헤드 없이 수행
* 메세지 브로커 사용
  * 게시자가 새 게시물을 제출할때 토픽에 생성
  * 트레이드 오프는 복잡성과 최종 일관성
* 더 높은 쓰기가 필요하면 카산드라나 HDFS같은 NoSQL 사용
## 7.14 이메일 서비스
* 게시물이 7일이 되면 게시자에게 갱신 알림
  * 7일된 게시물 쿼리, 이메일 전송 배치 ETL 구현
## 7.15 검색
POST 테이블에 엘라스틱서치 인덱스 생성
## 7.16 오래된 게시물 제거
* 크론이나 에어플로를 사용해 DELETE /old_posts 를 매일 호출하는 방식으로 구현
* AWS 글래시어같은 아카이브 스토리지에 저장하는 방법 고려
## 7.17 모니터링과 알림
* 오래된 게시물이 제거되지 않았을때
* 특정 용어의 높은 검색 횟수
* 신고된 게시물 수
## 7.19 기타 논의 가능한 주제
* 게시물 신고
  * 일정 수의 신고가 접수되면 삭제
  * 게시자의 계정 자동 차단
  * 이의 제기
* 점진적 성능 저하
  * 각 구성요소의 장애 처리 방안
* 복잡성
  * 종속성 최소화 : 라이브러리 최소화 (유지보수)
  * 클라우드 서비스 사용
  * 전체 웹페이지를 HTML 문서로 저장 (CDN에 키값 postID로 저장)
  * 관찰 가능성
* 품목 카테고리/태그
  * 품목 카테고리/태그를 제공하고 게시글에 추가할 수 있음
* 분석과 추천
  * 다양한 지표 대시보드를 위한 ETL을 만들 수 있음
* A/B 테스팅
* 구독과 저장된 검색
  * 검색어를 저장하고 새 게시물에 대한 알림을 받을 수 있음
* 속도 제한
* 지역규정
