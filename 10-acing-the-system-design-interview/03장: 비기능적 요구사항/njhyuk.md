# 3장: 비기능적 요구사항
비기능적 요구사항에 포함되는 것
* 확장성
* 가용성
* 성능/지연시간/P99와 처리량
* 내결함성
* 보안
* 프라이버시
* 정확성
* 일관성
* 비용
* 복잡성, 유지보수성, 디버깅 가능성과 테스트 가능성
## 3.1 확장성
* 스케일링
  * 수직 스케일링
    * 비용적, 기술적 한계
    * 다운타임 필요
  * 수평 스케일링
    * 여러 호스트에 분산
    * 진정한 확장성은 수평 스케일링
### 3.1.1 상태 비저장 서비스와 상태 저장 서비스
HTTP는 상태 비저장 -> 쉽게 확장, 공유 스토리지 쓰기는 확장이 어려움
### 3.1.2 기본 로드밸런서 개념
* 로드밸런서의 유형
  * 하드웨어 로드 밸런서
  * 공유 로드 밸런서: LBassS
  * 로드 밸런싱 소프트웨어가 설치된 서버 : HAProxy, Nginx
* 4계층 vs 7계층
  * 4계층 : 전송계층에서 작동함
    * 패킷만 전달할 수 있음
  * 7계층 : 응용계층에서 작동함
    * 로드밸런싱, 라우팅 결정, 인증, TLS 종료
* 고정 세션
  * 상태 저장 서비스에 사용
* 세션 복제
  * 호스트 쓰기가, 같은 세션에 할당된 클러스터의 다른 여러 호스트에 복사됨
* 로드밸런싱 vs 리버스 프록시
  * 로드밸런싱 : 확장성을 위함
  * 리버스 프록시 : 클라이언트-서버 통신을 관리하기 위함
    * 요청을 가로채고 전달, 게이트웨이 역할, 캐싱/압축/SSL 종료
### 3.2 가용성
* 시스템이 요청을 수락하고 원하는 응답을 반환할 수 있는 시간의 백분율
* 비기능적 요구사항을 논의할때
  * 높은 가용성이 필요한지 확정 필요
  * 높은 일관성과 낮은 지연시간과 트레이드 오프 할 수 있음
    * 이벤트 소싱, 사가 패턴
### 3.3 내결함성
* 일부 구성요소가 실패해도 시스템이 계속 작동할 수 있는 능력
* 다운타임이 발생해도 영구적인 데이터 손실을 방지하는 능력
* 복제와 중복
  * 구성요소의 중복 인스턴스/복사본을 3개 이상 가지는것
  * 2개가 동시에 다운돼도 가동시간 영향 X
* 전방 오류 수정과 오류 수정 코드
  * 오류 수정 코드와 같은 중복적인 방식으로 메시지를 인코딩해 노이즈나 불안정한 통신 채널을 통한 데이터 전송에서 오류를 방지하는 기법
* 서킷 브레이커
  * 클라이언트가 실패할 가능성이 높은 작업을 반복적으로 시도하는 것을 막는 매커니즘
* 지수 백오프와 재시도
  * 재시도 사이의 대기 시간을 지수적으로 증가
* 다른 서비스의 응답 캐싱
  * 실패할때 반환 값 대신 기본 응답이나 빈 응답 사용 또는 캐싱된 오래된 값 응답
* 체크포인팅
  * 체크포인트로 집계 작업이 어디까지 되었고, 재개할때 어디부터 시작해야 되는지 알 수 있음
    * ex) 카프카 오프셋
* 데드 레터 큐
  * 서드파티 API 요청이 실패하면, 요청을 데드레터 큐에 넣고 나중에 재시도
* 로깅과 주기적 감사
  * 무감지 오류를 처리하는 방법, 쓰기요청을 로깅하고 주기적 감사 수행
* 벌크헤드
  * 시스템을 격리된 풀로 나눠 한 풀의 결함이 전체 시스템에 영향을 미치지 않게함
* 폴백패턴
  * 문제를 탐지한 다음 대체 코드 경로를 실행
### 3.4 성능/지연 시간과 처리량
* 사용자의 요청이 시스템에 도달해 응답을 반환하는데 걸리는 시간
* 시스템의 기능적 요구사항은 사용자가 요청한 정보를 실제로 포함할 필요가 없고, 확인 응답과 함께 지정된 시간 후에 요청된 정보를 사용자에게 보내거나 사용자가 다른 요청을 통해 얻을 수 있다는 약속만으로 충분할 수 있음을 의미할 수 있음
  * ex) 응답을 200OK 만 보내고 나중에 보내져도 되는 메세징 시스템
  * 이러한 트레이드오프는 시스템 설계를 단순화할 수 있으므로, 우리는 항상 요구사항을 명확히 하고 사용자의 요청 후 얼마나 빨리 정보가 필요한지를 설명해야함
## 3.5 일관성
* 일관된 데이터베이스는 가용성, 확장성, 지연시간을 개선하기 위해 일관성을 트레이드 오프함
* 전체 메시
  * 클러스터의 모든 호스트는 다른 호스트의 주소를 가지고 있음
  * 모든 호스트에 브로드캐스트
  * 확장성이 없음
    * 메시지 수는 호스트 수에 따라 2차적으로 증가
* 조정 서비스
  * 다른 모든 노드는 리더에게 메세지를 보냄, 리더는 필요한 처리를 수행한 후 최종 결과를 다시 보냄
  * 각 노드는 자신의 리더와 통신, 각 리더는 일정 수의 노드를 관리
  * 주키퍼는 분산 조정 서비스임
  * 복잡성이라는 단점이 있음
* 분산 캐시
  * 서비스의 노드는 새 데이터를 가져올때 주기적으로 원본에 요청을 보내 캐시 업데이트
  * 단순하고 지연시간이 낮으며 서비스와 독립적으로 확장됨
* 가십 프로토콜
  * 각 노드는 주기적/무작위 간격으로 다른 노드를 무작위 선택 -> 데이터 공유
  * 더 낮은 비용과 복잡성을 위해 일관성을 트레이드 오프
* 무작위 리더 선택
  * 오직 하나의 리더를 보장하지 않아 여러 리더가 있을 수 있음
  * 중복 요청과 불필요한 네트워크 트래픽 단점
  * 카프카는 내결함성을 제공할때 무작위 리더 선택과 리더-팔로워 복제 모델을 사용
### 3.6 정확성
* 근사치가 아닌 정확한 값을 의미
* 추정 알고리즘은 정확성을 트레이드오프
* 최종적으로 일관된 시스템은 정확성을 트레이드오프
### 3.7 복잡성과 유지보수성
* 복잡성을 줄이고 유지보수성을 개선하려면 공통 서비스 적극 활용
* 시스템이 불가피하게 복잡하다면 가용성 및 내결함성을 낮추는 대신 복잡성을 줄이기
* 지속적 배포
  * CD는 쉬운 배포와 롤백을 가능하게하여 유지보수성 개선
### 3.8 비용
* 시스템 설계 논의에서 트레이드오프 할 것을 다음과 같이 제안
  * 수평확장 대신 수직 확장으로 복잡성을 낮추기 위한 더 높은 비용
  * 시스템의 중복성을 줄임으로써 가용성은 줄고 비용 절감
  * 사용자와 멀리 있지만 저렴한 위치의 데이터 센터 사용으로 비용 절감
* 비용 논의에는 시스템을 폐기하는 비용에 대한 고려 필요
### 3.9  보안
* 외부 당사자와 조직 내부로부터의 접근이 모두 포함된다.
* DDoS 공격을 방지하기 위한 속도 제한 방식을 논의할 수 있다.
### 3.10 프라이버시
* 개인정보 접근 제어 매커니즘을 적용해야 한다
* LDAP 같은 매커니즘을 사용할 수 있다
* 외부서비스 vs 내부서비스
  * 외부서비스를 설계한다면 보안과 프라이버시 매커니즘을 설계해야 한다
  * 내부 서비스도 내부 사용자가 악의적이지 않다고 믿어선 안된다
  * DB 접근을 로깅해야 한다
### 3.11 클라우드 네이티브
컨테이너, 서비스메시, MSA, 불변 인프라, 선언적 API가 이 접근 방식의 전형적인 예
