# 3 비기능적 요구사항
- 시스템입력과 출력 이외의 요구사항을 말함
  - 확장성
  - 가용성
  - 성능/지연 시간/P99과 처리량
  - 내결함성
  - 보안
  - 프라이버시
  - 정확성
  - 일관성
  - 비용
  - 복잡성, 유지보수성, 디버깅 가능성과 테스트 가능성
- 비 기능성 요구사항은 일반적으로 서로 트레이드 오프됨
### 3.1 확장성
- 시스템이 부하를 비용 효율적으로 지원할 때, 리소스 사용을 쉽고 번거롭지 않게 조정
- 수직 스케일링 세가지 단점
  - 금전적 비용이 업그레이드된 하드웨어의 성능보다 더 빠르게 증가
  - 수직 스케일링의 기술적 한계
  - 수직 스케일링에는 다운타임이 필요할 수 있음
- 해당 책에서는 스케일링에 대해 수평 스케일링을 칭함
##### 상대 비저장 서비스와 상태 저장 서비스
- HTTP는 상태 비저장 프로토콜 -> 백엔드에서 쉽게 수평 확장 가능
  - HTTP 백엔드와 수평 확장 가능한 데이터베이스 조합은 확장 가능한 시스템 설계 설명의 좋은 시작점
- 상태 저장과 상태 비저장 간의 트레이드 오프를 통한 설계
##### 기본 로드 밸런스 개념
- 모든 수평 확장 서비스는 다음 중 하나의 로드밸런서를 사용
  - 하드웨어 로드 밸런서(L4)
  - 공유 로드 밸런서 서비스(LBaaS)
  - 로드 밸런싱 소프트웨어가 설치된 서버(L7)
- 4계층 vs 7계층
  - 4계층은 전송 계층(TCP)에서 작동
    - 패킷에서 추출한 주소 정보를 기반으로 라우팅 결정을 내리고 다른 패킷의 내용은 검사하지 않음
  - 7계층은 응용 계층(HTTP)에서 작동
    - 로드 밸런싱/라우팅 결정 -> 패킷의 내용 기반
    - 인증-> 401 반환
    - TLS 종료
- 고정 세션(Sticky session)
  - 로드 밸런서가 특정 클라이언트의 요청을 특정 호스트로 보내는 것
  - 상태 저장 서비스에 사용됨
  - 기간 기반이나 제어 쿠키를 통해 구현 가능
- 세션 복제
  - 호스트 쓰기 같은 세션을 할당된 클러스터의 다른 여러 호스트에 복사되므로 해당 세션을 가진 어떤 호스트로도 일기 라우팅 가능 -> 가용성 향상
- 로드 밸런싱 vs 리버스 프록시
  - 로드 밸런싱은 확장
  - 리버스 프록시는 클라이언트 - 서버 통신을 관리하기 위한 기술
    - 요청 URI나 다른 기준에 따라 적절한 서버로 들어가게 전달하는 게이트 역할
### 3.2 가용성
- 시스템을 요청을 수락하고 원하는 응답을 반환할 수 있는 시간의 백분율

| 가용성 %  | 연간 다운타임 | 월간 다운타임 | 주간 다운타임 | 일간 다운타임 |
|--------|---------|---------|---------|---------|
| 99.9   | 8.77시간  | 43.8분   | 10.1분   | 1.44분   |
| 99.99  | 52.6분   | 4.38분   | 1.01분   | 8.64초   |
| 99.999 | 5.26분   | 26.3초   | 6.05초   | 864밀리초  |

- 높은 가용성을 위해 넷플리스는 다중 지역 동시 활성화(Active-Active) 방식 배포
- 대부분의 서비스는 높은 가용성이 필요하며, 불필요한 복잡성 없이 높은 가용성을 허용하기 위해 다른 비기능성 요구사항을 트레이드 오프 가능
- 높은 일과성과 낮은 지연 시간이 필요하다고 가정하지 말아야함
- Cap 정리를 참조하여 가용성을 옾이기 위해 이를 트레이드 오프 고려
  - 이벤트 소싱과 사가 패턴과 같은 비동기식 커뮤니케이션 기술을 사용하여 이를 달성
- 요청을 즉시 처리하고 응답을 즉시 반환할 필요가 없는 서비스는 높은 일관성과 낮은 지연 시간이 필요할 가능성이 낮음
  - 즉각적인 응답이 절대적으로 필요하면 동기식 통신 프로토콜 사용
  - 요청 데이터를 몇 분 또는 몇 시간 후에 반환할 수 있는지 고려 -> 메시지 큐 활용
- 높은 가용성이 필요 없는 상황의 예로 캐싱 서비스 -> 낮은 지연 시간 확보로 가용성 트레이드 오프 처리
- 가용성은 인시던트 지표로도 측정 가능
  - MTTR(평균 복구 시간)과 MTBF(평균 고장 간격 시간) 같은 지표로 설명
### 3.3 내결함성
- 일부 구성 요소가 실패해도 시스템이 계속 작동할 수 있는 능력과 다운타임이 발생했을 때 영구적인 데이터 손실 등을 방지
  - 엔지니어에게 실패한 부분을 해결하고 정상 상태로 복원할 시간을 벌어줌
  - 가용성은 가동 시간/다운타임의 척도, 내결함성은 척도가 아니라 시스템 특성
- 내결함성 기법
##### 복제와 중복
- 한 가지 복제 기법은 구성 요소의 중복 인스턴스/복사본을 3개 이상 가지는 것
  - 최대 2개가 동시에 다운돼도 가동 시간에 영향을 미치지 않게 하는 것
- 한 인스턴스는 원본으로 지정되고, 다른 두 구성 요소는 복제본(팔로워)으로 지정
##### 전방 오류 수정(FEC)과 오류 수정 코드(ECC)
- 중복적인 방식으로 메시지를 인코딩해 노이즈나 불안정한 통신 채널을 통한 데이터 전송에서 오류를 방지하는 기법
##### 서킷 브레이커
- 클라이언트가 실패할 가능성이 높은 작업을 반복적으로 시도하는 것을 막는 메커니즘
  - 다운스트림 서비스와 관련해 최근 간격 내에 실패한 요청 수를 계산 -> 임계값이 넘으면 호출 중단 후 일정 시간 후 요청 시도
- 실패할 가능성이 높은 요청에 리소스를 소비하지 않게 해줌, 이미 과부하 상태인 시스템에 클라이언트가 과하게 부담을 주는 것을 방지
- 서킷 브레이커는 시스템 테스트를 더 어렵게 함 -> 잘못된 요청을 하고 있지만 부하처리가 되고 있다고 판단할 수 있고, 적절한 임계치를 계산하기 어려움
##### 지수 백오프와 재시도
- 서킷 브레이커와 유사
- 오류 응답을 받고 바로 재시도 보다 대기 시간을 지수적으로 증가 후 시도
- 서버 부하를 막기 위한 방법
##### 다른 서비스의 응답 캐싱
- 특정 데이터의 외부 서비스의 의존 가능 -> 다른 서비스 사용할 수 없다면? 반환 값 대신 기본 값 또는 빈값 전달
  - 데이터가 없는 것보다 오래된 데이터가 나을 때가 존재
##### 체크포인팅
- 서버는 많은 데이터 포인트에 특정 데이터 집계 작업을 수행할 수 있음
- 데이터가 처리되다가 특정 시점에 실패하면 실패 포인트를 알아야 대체 서버에서 이어서 진행 가능 -> 어느 데이터 포인트부터 집계해야하는지 체크 포인트 기록
- 대체 서버는 체크 포인트를 통해 작업 진행 가능
- 카프카와 같은 메시지 브로커(오프셋) 또는 ETL 파이프라인에 일반적으로 적용됨
##### 데드 레터 큐
- 서드파티 API 쓰기 요청이 실패하면 요청을 데드 레터 큐에 넣고 나중에 시도 가능
- 데드 레터큐는 로컬 저장? 별도의 서비스 저장? 복잡성과 신뢰성을 트레이드 오프
##### 로깅과 주기적 감사
- 무감지 오류를 처리하는 한가지 방법은 쓰기 요청을 로깅하고 주기적으로 감사를 수행
- 감사 작업은 로그를 처리하고 우리가 쓰는 서비스의 데이터가 예상 값과 일치하는지 확인
##### 벌크헤드
- 내결함성 메커니즘으로, 시스템을 격리된 풀로 나눠 결함이 전체 시스템 영향을 미치지 못하게함
  - 서비스 내 엔드 포인트 별 스레드풀을 나눠 한쪽 스레드 풀이 고갈되더라도 다른 엔드포인트에 영향이 없도록 처리
##### 폴백 패턴
- 문제를 탐지한 다음 대체 코드 경로를 실행하는 것
  - 유시한 대체 서비스나 이전 데이터 반환을 통한 오류 방지
### 3.4 성능/지연 시간과 처리량
- 성능이나 지연 시간은 사용자의 요청이 시스템에 도달해 응답을 반환하는데 걸리는 시간
- 낮은 지연 시간을 달성하기 위한 설계 결정 
  - 사용자와 가까운 데이터 센터에 서비스를 배포
  - CDN 사용
  - 캐싱
  - REST 대신 RPC로 데이터 크기 줄이기
  - 네티와 같은 프레임워크로 자체 프로토콜 설계하여 HTTP 대신 TCP와 UDP 사용
  - 배치와 스트리밍 기법 존재
### 3.5 일관성
- ACID와 CAP 정리에서 다른 의미를 가짐
  - ACID 일관성은 외래 키와 고유성 같은 데이터 관계에 중점을 둠
  - CAP 일관성은 실제로 선형(모든 연산이 시간 순서대로 정확히 한 번씩 실행된 것)화 가능성
    - 특정 시점에 동일한 데이터를 포함하는 모든 노드가 선형
    - 데이터 변경은 노드가 동시에 변경사항을 제공하기 시작해야 하는 것
- 일관된 데이터베이스는 가용성, 확장성, 지연 시간을 개선하기 위해 일관성을 트레이드오프 해야함
  - RDBMS를 포함한 ACID 데이터베이스는 네트워크 분할이 발생하였을 때, 쓰기를 수락할 수 없음 -> 쓰기를 허용하면 ACID 일관성을 유지할 수 없음

| 선형성 선호  | 가용성 선호  |
|---------|---------|
| HBase   | 카산드라    |
| MongoDB | CouchDB |
| 레디스     | 다이나모    |
|         | 하둡      |
|         | Riak    |

- 논의 중에 ACID와 CAP 일관성 차이, 선형화 가능성과 최종 일관성 사이의 트레이드 오프를 강조해야함
- 선형화 가능성과 최종 일관성을 위한 다양한 기법을 설명
###### 전체 메시
- 클러스터의 모든 호스트는 다른 호스트의 주소를 가지고 있으며 브로드 캐스트함
- 메시지 수는 호스트 수에 따라 2차적으로 증가
###### 조정 서비스
- 리더 노드나 리더 노드 집항을 선택하는 서드파티 구성 요소인 조정 서비스 존재
- 다른 리더에게 메시지를 보내고, 리더는 필요한 처리를 수행한 후 최종결과를 다시 보낼 수 있음
- 각 노드는 자신의 리더나 리더 집합과 통신하면 되고, 리도는 일정 수의 노드를 관리
- Paxos, Raft, Zab 알고리즘 존재
- 단점은 복잡성
  - 높은 신뢰성을 가져야 하고 오직 하나의 리더만 선출되어야하는 정교한 구성
###### 분산 캐시
- 레디스나 Memcached 같은 분산 캐시 사용 -> 새 데이터를 가져올 때 주기적으로 원본에 요청을 보낸 다음 분산 캐시에 요청을 보내 데이터를 업데이트할 수 있음
  - 전체 메시를 제외한 다른 모든 해결책보다 더 많은 요청을 받음
- 보안적 이슈에 대해 보완하려면 복잡성과 비용 증가, 성능 저하 동반
###### 가십 프로토콜
- 전염병이 퍼지는 방식을 모델 -> 각 노드는 주기적 또는 무작위 간격으로 다른 노드를 무작위로 선택한 다음 데이터 공유
  - 낮은 비용과 복잡성을 위해 일관성을 트레이드 오프함
- 카산드라 및 다이나모 DB가 해당 방식 활용
###### 무작위 리더 선택
- 리더를 선출 할 때 간단한 알고리즘을 사용, 오직 하나의 리더만 보장하지 않으므로 여러 리더가 있을 수 있음
- 각 리더가 모든 다른 호스트와 데이터를 공유, 모든 호스트가 동일한 데이터를 가지는 형태
- 단점은 중복 요청과 불필요한 네트워크 트래픽이 발생 가능
### 3.6 정확성
- 복잡한 데이터 처리나 높은 쓰기 빈도를 가진 시스템에서는 중요한 비기능적 요구사항
- 정확성은 어느 정도 일관성과 관련
  - 최종적으로 일관된 시스템은 가용성, 복잡성, 비용 개선하기 위해 정확성을 트레이드 오프
  - 최종적으로 일관된 시스템에서는 쓰기가 이뤄지면 읽기 결과에 쓰기 영향이 포함되지 않아 부정확할 수 있음 -> 정확성이 아닌 일관성 용어로도 사용됨 

※ 정확성과 일관성 헷갈렸음 -> 정확성은 시스템 외부(현실)와 내부간 데이터에 대한 일치성, 시스템 내부에서의 일관성 분산된 데이터간 일치성

### 3.7 복잡성과 유지보수성
- 복잡성을 최소화 하는 첫 단계는 기능적 요구사항과 비기능적 요구사항을 모두 명확히 하는 것 -> 불필요한 요구사항에 대해 설계하지 않음
- 복잡성을 줄이고 유지보수성을 개선하려면 다양한 서비스에 적용 가능한 공통서비스를 적극적으로 활용해야함
  - 로드 밸런서 서비스
  - 속도 제한 방식
  - 인증과 인가
  - 로깅, 모니터링, 알림
  - TLS 종료
  - 캐싱
  - 데브옵스와 CI/CD
- 복잡한 시스템에 높은 가용성과 내결함성을 확보하려면 시스템이 복잡해질 수 있음
  - 시스템이 불가피하게 복잡하다면 가용성 및 내결함성을 낮추는 대신 복잡성을 줄이는 것을 고려
- 지속적 배포(CD)
  - 쉬운 배포와 롤백이 가능 -> 실수로 인핸 롤백이 빠르게 처리
  - 점진적 업그레이드와 새로운 기능의 빠르고 쉬운 배포는 SW 개발 생명주기로 이어짐
### 3.8 비용
- 시스템 설계 논의에서 더 낮은 비용을 위해 다른 비기능적 요구사항을 트레이드 오프 논의
  - 수직 확장으로 복잡성을 낮추고 비용을 높임
  - 시스템 중복성(호스트 수나 데이터 복제 계수)을 줄이며 가용성을 줄이고 비용 줄임
  - 더 저렴한 위치의 데이터 센터를 사용해 비용 줄이고 지연 시간 증가
- 유지보수 비용 외에도, 시간이 지남에 따라 라이브러리와 서비스가 폐기되면서의 노후화로 인한 비용 고려
- 완전 비용 논의에는 시스템을 폐기하는 비용에 대한 고려도 포함되어야 함
### 3.9 보안
- 보안 취약점과 침해를 어떻게 예방하고 해소할 것인지 논의 필요
  - TLS 종료와 데이터 센터의 서비스나 호스트 간 전송 중 데이터 암호화 유지
  - 암호화 하지 않고 저장할 수 있는 데이터와 암호화하여 저장해야하는 데이터 구분
- OAuth 2.0과 OIDC를 어느정도 이해하고 있어야 함
- DDos 공격 방지를 위한 속도 제한(Rate limit) 고려
### 3.10 프라이버시
- 개인 식별 정보(PII)에 대해 일반 데이터 보호 규정(GDPR)과 캘리포니아 소비자 개인정보 보호법(CCPA) 등의 규정을 준수하기 위해 안전하게 보호되어야함
  - 시스템 내 데이터베이스와 파일에 저장된 PII 접근 제어 메커니즘을 적용 필요(LDAP 메커니즘 활용 가능)
  - SHA-2(3) 같은 해싱 알고리즘을 통해 PII 마스킹 하고 집계 통계에도 프라이버시 고려 필요
- 외부 서비스 vs 내부 서비스
  - 외부 서비스를 걸계하면 보안과 프라이버시 메커니즘을 반드시 설계 필요
  - 내부 서비스라고 해도 기본적으로 보안과 프라이버시 메커니즘을 구현해야함
### 3.11 클라우드 네이티브
- 확장성, 내결함성, 유지보수성을 포함한 비기능적 요구사항을 해결하기 위한 접근 방식
- 클라우드 네이티브 기법(컨테이너, 서비스 메시, 마이크로 서비스 등)을 통해 비기능적 요구사항 달성
### 3.12 추가자료
- PACELC -> CAP 이론 정리 확장
  - 네트워크 분할(P)이 생기면 가용성(A)과 일관성(C) 하나를 선택, 그렇지 않으면 지연 시간과 일관성 중 하나를 선택해야함 