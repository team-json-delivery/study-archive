## 13. 콘텐츠 배포 네트워크 설계하기

CDN(Content Distribution Network)은 비용 효율적이고 지리적으로 분산된 파일 저장 서비스로, 여러 데이터 센터에 파일을 복제하여 대규모의 지리적으로 분산된 사용자에게 빠르게 정적 콘텐츠를 제공

#### 13.1 CDN의 장단점
- 장점
  - 낮은 지연시간: 가까운 데이터 센터에서 서비스 제공으로 SEO 향상
  - 확장성: 서드파티가 스케일링을 관리
  - 낮은 단위 비용: 대량 할인과 규모의 경제
  - 높은 처리량: 더 많은 동시 사용자 처리 가능
  - 높은 가용성: 지리적 분산으로 장애 대응력과 트래픽 분산
- 단점
  - 복잡성 증가: 추가 DNS 조회, 새로운 장애 지점
  - 비용 문제: 낮은 트래픽에서 높은 단위 비용, 숨겨진 데이터 전송 비용
  - 마이그레이션 어려움: 수개월 소요, 높은 비용
  - 네트워크 제한: 특정 국가/조직의 IP 차단 가능
  - 보안/프라이버시: 서드파티 데이터 저장, JavaScript 라이브러리 악성 코드 위험
  - 제어권 부족: SLA 의존성, 커스터마이제이션 한계
- 예상치 못한 문제 사례 
  - WebP 자동 변환 문제:
    - CDN이 User-Agent 헤더를 보고 자동으로 WebP 형식으로 이미지 변환
    - 원본 형식이 필요한 애플리케이션에서 문제 발생
  - 해결책:
    1. User-Agent 헤더 재정의 (브라우저 제한)
    2. CDN 개별 서비스 설정 (제한적)
    3. 백엔드 서비스 경유 (CDN 장점 상쇄)

#### 13. 2 요구사항
- 기능적 요구사항
  - 권한 있는 사용자의 디렉토리 생성
  - 10GB 제한의 파일 업로드
  - 파일 다운로드

- 비기능적 요구사항
  - 확장성: 페타바이트 저장, 일일 테라바이트 다운로드
  - 고가용성: 99.99% 이상 업타임
  - 고성능: 가장 빠른 데이터 센터에서 파일 제공
  - 내구성: 파일 손상 방지
  - 보안/프라이버시: 권한 있는 사용자만 접근

#### 13. 3 CDN 인증과 권한 부여
- CDN 인증과 권한 부여 단계
  - 토큰 생성 단계
    1. 사용자 인증: 고객 앱에 인증 요청
    2. 토큰 생성: SDK를 사용해 다음 정보로 액세스 토큰 생성
    3. 토큰 저장: 고객 앱이 토큰을 저장하고 사용자에게 반환
    4. URL 서명: CDN 자산 요청 시 서명된 URL 사용
    5. 토큰 삭제: 로그아웃 시 토큰 파기  
  - Referrer 헤더와 보안
    - 클라이언트가 HTTP 요청 시 고객 URL을 Referrer 헤더에 포함
    - CDN은 인증된 리퍼러만 허용
    - 한계: 클라이언트가 쉽게 스푸핑 가능하여 완전한 보안 메커니즘은 아님
- 키 교체
  - 목적: 해커의 키 탈취 시 피해 제한
  - 방식: 점진적 교체 (갑작스런 변경 아님)
  - 과정: 구 키와 신 키 동시 유효 기간 → 설정 시간 후 구 키 만료

#### 13. 4 상위 수준 아키텍처
- 아키텍처 구성
```
[Users] → [API Gateway] → [Storage Service]
                ↓
    [Rate Limiting Service]
    [Metadata Service]
    [Logging Service] 
    [Secrets Management Service]
    [Origin]
```
- 주요 컴포넌트
  - API Gateway: SSL 종료, 인증/권한부여, 속도제한, 로깅
  - Storage Service: 실제 파일 저장
  - Metadata Service: 파일 위치 및 메타데이터 관리
  - Secrets Management Service: 암호화 키 관리 (암호화 시)
- 운영 방식
  - 읽기: 다운로드
  - 쓰기: 디렉토리 생성, 업로드, 파일 삭제
  - 초기 설계: 모든 파일을 모든 데이터 센터에 복제

#### 13. 5 저장소 서비스
- 기본 설계 원칙
  - 호스트/노드 클러스터 구성
  - 파일은 호스트 파일시스템에 저장 (DB 사용 X)
  - 가용성/내구성을 위한 다중 호스트 복제 (예: 3개)
  - 가용성 모니터링 및 장애조치 프로세스 필요
- 클러스터 내부
  - HDFS + ZooKeeper 같은 분산 파일 시스템 사용
  - ZooKeeper가 리더 선출 및 파일-리더-팔로워 매핑 관리
  - 고도로 정교하지만 높은 신뢰성/확장성/성능 요구
- 클러스터 외부
  - 3개 이상 노드의 소규모 독립 클러스터들로 구성
  - 메타데이터 서비스가 클러스터 식별 후 랜덤 노드 선택
  - 선택된 노드가 클러스터 내 다른 노드로 복제 담당
  - 리더 선출 불필요, 파일-클러스터 매핑 필요
- In-cluster vs Out-cluster 비교

| 구분 | In-cluster | Out-cluster |
|------|------------|-------------|
| 메타데이터 서비스 요청 | 불필요 | 필요 |
| 파일 할당 관리 | 클러스터 내 개별 역할 | 클러스터 단위 |
| 노드 인식 | 모든 노드 파악 | 클러스터 단위 파악 |
| 모니터링 | 노드별 하트비트 | 독립 클러스터별 상태 |
| 장애 처리 | 노드 장애/추가 | 과부하 클러스터 추적 |

#### 13. 6 일반적인 작업
- 읽기 (다운로드)
  - 메타데이터 서비스 역할
    - 파일을 포함하는 저장소 서비스 호스트 정보 (Redis/SQL 사용)
    - 각 데이터 센터 호스트의 현재 부하 추적
    - 파일 크기, 해시값 (MD5/SHA) 정보
    - 파일 소유권 및 접근 제어
    - 호스트 상태 정보
  - 다운로드 프로세스 (CDN에 자산 보유 시)
    1. 속도 제한 확인: Rate Limiting Service 조회
    2. 메타데이터 조회: 저장소 호스트 정보 획득
    3. 파일 스트리밍: 저장소 호스트 선택하여 클라이언트에 전송
    4. 부하 업데이트: 메타데이터 서비스의 호스트 부하 갱신
  - CDN 미보유 자산 처리
    - 발생 상황:
      - 보존 기간 만료
      - 업로드 실패했으나 고객이 성공으로 인식
      - 기타 CDN 오류 
    - 처리 과정:
      1. Origin에서 다운로드: 백업 위치에서 자산 획득
      2. 병렬 처리: 클라이언트 반환과 동시에 저장소 저장
      3. 메타데이터 업데이트: 새로운 저장 위치 정보 갱신
  - 암호화 자산 다운로드
    1. Secrets Management Service → 암호화 키 획득
    2. Storage Service → 암호화된 자산 가져오기
    3. 자산 복호화 → 클라이언트에 반환
- 쓰기 (업로드)
  - 파일 식별 및 중복 처리
    - 파일 식별: ID 기반 (이름 아님)
    - 동일 내용 파일: 다른 소유자라도 별도 저장 (초기 설계)
    - 향후 최적화: 저장소 비용 절감 시 중복제거 고려 
  - Multipart Upload
    - 개념:
      - 대용량 파일을 청크 단위로 분할 업로드
      - 체크포인팅과 유사한 개념 
    - 프로세스:
      1. 청크 분할: 고정 크기 (예: 128MB)로 분할
      2. 메타데이터 전송: 사용자 ID, 파일명, 크기, 청크 번호
      3. 주소 할당: 저장소 호스트가 디스크 주소 범위 할당
      4. 청크 업로드: 적절한 주소에 청크 작성
      5. 완료 처리: 최종 청크 업로드 시 복제/다운로드 준비 상태로 마킹
    - 장점:
      - 실패 시 해당 청크만 재업로드
      - 미디어 파일의 경우 첫 청크 다운로드 시 즉시 재생 가능
  - 파일 추가/업데이트/삭제 처리 
    - 접근 방식들:
      1. Single-leader: 특정 데이터 센터가 작업 수행 후 전파
      2. Multi-leader: 튜플 사용한 다중 리더 방식
      3. 클라이언트 락: 모든 데이터 센터에서 락 획득 후 작업
  -  데이터 센터별 선택적 복제
    - 배경:
      - 특정 지역에서 주로 사용되는 파일들 존재 (언어별 오디오/텍스트)
      - 모든 데이터 센터에 복제할 필요 없음 
    - 복제 기준:
      - 지난 한 달간 요청 수/사용자 수
      - 데이터 센터 내 장애 허용을 위한 복제는 여전히 필요
  - Saga 패턴을 이용한 분산 파일 관리
    - Choreography 방식:
      1. 셔플링 작업 → 셔플링 토픽 이벤트 생성
      2. 저장소 서비스 → 새 위치에 파일 작성
      3. 저장소 서비스 → 메타데이터 토픽에 업데이트 요청
      4. 메타데이터 서비스 → 파일 위치 메타데이터 업데이트
      5. 메타데이터 서비스 → 파일 삭제 토픽에 삭제 요청
      6. 저장소 서비스 → 구 위치에서 파일 삭제 
    - Orchestration 방식:
      - 메타데이터 서비스가 오케스트레이터 역할
      - 파일 생성 → 응답 대기 → 메타데이터 업데이트 → 구 파일 삭제 
    - 트랜잭션 타입:
      - Compensable: 6단계 이전의 모든 트랜잭션
      - Pivot: 6단계 파일 삭제 (비가역적)
      - Retriable: 없음 (마지막 단계이므로)

#### 13. 7 캐시 무효화
- CDN 특성:
  - 정적 파일 대상이므로 캐시 무효화는 큰 문제가 아님
  - 파일 핑거프린팅 기법 사용
  - 다양한 캐싱 전략 적용
  - 높은 트래픽 대응 모니터링 시스템 필요

#### 13. 8 로깅, 모니터링, 경보
- 모니터링 대상
  - 업로드 상태: 진행 중/완료/실패 추적
  - CDN 미스: 로깅 및 낮은 우선순위 알림
  - 요청률: 파일별 요청률 로깅 (공유 로깅 서비스)
  - 비정상 활동: 악성 활동 모니터링

#### 13. 9 미디어 파일 다운로드에 대한 기타 가능한 논의
- 부분 재생 지원
  - 요구사항:
    - 전체 다운로드 완료 전 미디어 파일 재생 가능 
  - 해결책:
    - 미디어 파일을 작은 파일들로 분할
    - 순차 다운로드 및 조립으로 부분 버전 생성
    - 클라이언트 측 미디어 플레이어의 조립 기능 필요 
  - 구현 요소:
    - 파일별 시퀀스 번호 할당
    - 다운로드 순서 정보가 포함된 메타데이터 파일
    - 총 파일 수 정보
