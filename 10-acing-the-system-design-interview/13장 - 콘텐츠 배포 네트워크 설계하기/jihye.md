# chapter 13. 컨텐츠 배포 네트워크 설계하기

CDN contents delivery network

- 여러 데이터센터에 걸쳐 파일을 복제해 지리적으로 분산된 많은 사용자에게 정적 컨텐츠를 빠르게 제공하게 설계

## 13.1 CDN의 장단점

### 13.1.1 CDN의 장점

- 낮은 지연시간 lower latency
    - 가까운 데이터센터에서 서비스를 받으므로 지연시간이 낮다.
    - Search engine optimization 개선 등의 이점도 가질 수 있다
- 확장성 scalability
    - 서드파티 업체를 사용하면 직접 확장할 필요 없다.
- 낮은 단위 비용 lower unit costs
    - 서드파티는 일반적으로 대량 할인 제공
    - 많은 트레픽 처리하는 규모의 경제
        - 하드웨어, 적절한 기술 인력 비용을 더 큰 볼륨에 분산시켜 낮은 비용 제공
    - 더 안정적 수요를 만들 수 있음
- 높은 처리량 higher throughput
    - 추가 호스트를 제공해 더 많은 동시 사용자
    - 더 높은 트래픽 처리
- 높은 가용성 higher availability
    - cdn이 SLA service level agreement 서비스 수준 계약을 유지할 수 있으면 자사 서비스의 호스트 실패시 대체 수단으로 작용할 수 있음

### 13.1.2 CDN 사용의 단점

- 추가적인 복잡성
    - 추가적인 DNS 조회
    - 추가적인 실패 지점
- 트래픽이 적을 경우 높은 단위 비용을 가질 수 있음
    - 데이터 전송당 GB 비용 등 숨겨진 비용이 있을 수 있음
- 다른 CDN으로 마이그레이션 하는데 많은 시간과 비용이 들 수 있음
    - CDN 폐업, CDN 회사가 SLA를 이행하지 않는 경우
    - 고객 지원이 열악한 경우
    - 특정 CDN이 사용자 근처에 호스트를 두지 않는 경우, 커버하기 위해 적합한 CDN으로 마이그레이션 해야 할 수 있음
- 일부 국가나 조직이 특정 CDN의 IP를 차단할 수 있음
- 서드파티에 저장 → 보안, 프라이버시 우려
    - 저장시 암호화를 하면 추가적 비용, 적절한 보안 엔지니어 인력 필요
        - 팀에 추가 비용, 의사소통 부담
- javascript library 에 악성 코드 삽입 가능성
    - 원격 호스팅 라이브러리의 보안, 무결성 보장하기 어려움
- CDN에 문제가 생겼을 때 3rd파티 회사가 이를 해결하는데 얼마나 시간이 걸릴지 예측하기 어려움

### 13.1.3 이미지 제공 CDN을 사용할 때 발생할 수 있는 예상치 못한 문제의 예

- CDN은
    - get 요청 시 user-agent의 해더를 읽어 요청이 웹 브라우저에서 온 것인지 확인
    - 업로드 된 png, jpeg형식을 WebP 형식으로 반환할 수 있음
- 원본 형식으로 이미지를 반환받고자 한다면
    - 웹 application에서 user-agent 해더를 재정의
        - 특정 웹 브라우저 (파이어폭스 등)가 아니면 재정의가 안됨
    - 특정 서비스에는 WebP를 제공, 그외에는 원본으로 제공하게 CDN 구성
        - CDN 구성을 관리하는 인프라팀이 개별 서비스에 이 구성 설정을 할수 없을 수 있음
    - 요청을 백앤드 서비스를 통해 라우팅
        - api endpoint를 노출해야 함.
        - 백앤드 호스트가 지리적으로 사용자와 멀 수 있어 CDN의 이점을 잃게 됨
        - 대신 backend service와 같은 데이터 센터에 호스트가 있는 더 저렴한 객체 저장소에 파일을 저장할 수도..

## 13.2 요구사항

- 기능 요구사항
    - 권한이 있는 사용자
        - 디렉터리를 만들고
        - 10GB 크기 제한으로 파일을 업로드/다운로드
- 비기능 요구사항 (CDN의 장점)
    - 확장성 Scalable
        - 페타 바이트 규모의 저장용량과 하루 테라바이트 수준의 다운로드 용량을 지원할 수 있게 확장해야 됨
    - 고가용성 High availability
        - 4~5개의 9로 표현되는 99.99% or 99.999%의 가동시간 필요
    - 고성능 high performance
        - 파일은 요청자에게 빠르게 제공 데이터 센터에서 다운로드
        - 업로드 성능은 상대적으로 덜 중요
    - 내구성 Durable
        - 파일이 손상되면 안됨
    - 보안, 프라이버시 security, privacy
        - 권한이 있는 사용자만 파일을 다운로드/업로드 할 수 있어야 함

## 13.3 CDN 인증과 권한 부여

- 인증
    - 사용자 식별
- 인가
    - CDN 파일에 접근하는 사용자가 리소스 권한을 가지고 있는지 확인
    - Hotlinking(이미지를 허가없이 직접 링크해서 사용하는 행위) 을 방지
- 인증, 권한부여는 쿠키기반 인증, 토큰 기반 인증으로 할 수 있다.
    - 토큰 기반 인증은 메모리를 덜 사용
    - 보안 전문성이 더 높은 3rd-party 서비스를 사용할 수 있음
    - 세밀한 접근 제어 가능
    - 토근 인증은 허용된 ip 주소나 특정 사용자 계정으로 제한할 수도 있음

### 13.3.1 CDN 인증과 권한 부여 단계

1. 사용자가 CDN에 인증요청을 보냄
    1. 단순 로그인, openID Connect 등
2. CDN 사용 업체 앱이 SDK를 사용해 접근 토큰 생성
    1. secret key - 사용 고객의 비밀 키
    2. CDN url - 생성된 접근 토큰이 유효한 cdn url
    3. expiry 만료 - 만료된 토큰으로 요청하면 302 redirection
    4. 레퍼러 referrer

       > 레퍼러 해더와 보안
       >
       > - CDN은 승인된 referrer만 허용
       > - 적절한 보안 체계가 아니어서 쉽게 위조할 수 있
    5. 허용된 IP
    6. 허용된 국가나 지역 allowed countires or regions
3. 고객 앱이 토큰을 저장 후 이를 사용자에게 반환
    1. 암호화된 형태로 저장
4. 고객 앱이 사용자에게 CDN url을 제공할 때마다, get요청을 할 때마다 URL 서명 해야 됨 (접근 토큰으로 서명)
5. 사용자가 로그아웃하면 토큰 파기
    1. 로그인할 때마다 토큰 생성

그림 13.1

- 토큰 삭제는 비동기적일 수 있거나 / 로그아웃은 빈번한 이벤트가 아니어서 동기적일 수도 있음
    - 삭제를 처리하는 CDN 호스트가 실패할 때 토큰이 삭제되지 않을 수 있음
        - 해결책 1
            - 일부 토큰이 파기되지 않게 허용
        - 해결책 2
            - 이벤트 기반 접근법
                - 카프카 큐에 토큰 삭제 이벤트를 생성, 그 이벤트를 소비해서 토큰을 삭제
        - 해결책 3
            - 토큰 삭제를 동기식/차단 방식으로 구현
            - 토큰 삭제가 실패하면 500 error를 받고 로그아웃 요청을 재시도 → 지연시간을 높이지만 수용 가능

### 13.3.2 키 교체

- key rotation
    - 이전 키와 새 키가 모두 유효한 기간을 포함하는 키 갱신 과정
    - 새 키가 고객 모든 시스템에 전파되는데 시간이 걸리므로 그 사이에 두 키를 모두 사용할 수 있지만
    - 정해진 만료시간에는 만료 됨 → 만료된 키로 cdn 자산에 접근 불가능
        - 해커 대비..

## 13.4 상위 수준 아키텍쳐

- 그림 13.2
- api gateway-metadata 저장소/데이터베이스 아키텍쳐 채택
- api gateway
    - ssl 종료, 인증, 권한부여, 속도 제한 방식, 로깅 시스템 (분석/요긍 청구)가 포함
    - 메타데이터 서비스를 조회해 모든 사용자를 어떤 저장소 서비스 호스트에서 읽거나 쓸 지 결정

## 13.5 저장소 서비스

- 파일을 포함하는 호스트/노드의 클러스터
- 파일은 file system에 저장해야 됨
- 가용성, 내구성을 위해 파일을 복제하고 각 파일을 여러 호스트에 할당해야 함
- 장애 조치 프로세스 필요
- host관리자는 클러스터 외부/내부에 있을 수 있음

### 13.5.1 클러스터 내부

- hdfs같은 분산 파일시스템을 사용
    - 주키퍼를 클러스터 내부 관리자로 포함
        - 리더 선출 관리
        - 파일, 리더, 팔로워 간 매핑을 유지
- 클러스터 내부 관리자 → 신뢰성, 확장성, 고성능이 필요한 매우 정교한 구성 요소

### 13.5.2 클러스터 외부

- 각 클러스터는 여러 데이터 센터에 분산된 3개 이상의 노드로 구성
- 메타 데이터 서비스가 파일이 저장/저장 될 클러스터를 식별 후 무작위로 선택한 노드에서 파일을 읽거나 씀
- 리더 선출 필요는 없지만 파일을 클러스터에 매핑하는 것이 필요
- 외부 관리자는 파일, 클러스터 매핑을 유지

### 13.5.3 평가

표 13.1

| 클러스터 내부 관리자 | 클러스터 외부 관리자 |
| --- | --- |
| 메타데이터 서비스가 클러스터 내부 관리자에게 요청하지 않음 | 메타데이터 서비스가 클러스터 외부 관리자에게 요청 |
| 클러스터 내 개별 역할의 파일 할당 관리 | 클러스터로의 파일 할당을 관리 |
| 클러스터의 모든 노드를 알아야 함 | 각 개별 노드에 대해서는 알지 못할 수 있음, 각 클러스터에 대해서는 알아야 함 |
| 노드의 하트비트 모니터 | 각 독립 클러스터의 상태를 모니터 |
| 호스트 실패를 처리. 노드가 죽을 수도 있고 새 노드가 클러스터에 추가될 수 있다 | 각 클러스터의 사용률을 추적, 과부화된 클러스터 처리. 한계치의 클러스터에는 더이상 새 파일을 할당하지 않음 |

## 13.6 일반적인 작업

- 클라이언트가 CDN domain으로 요청하면 GeoDNS가 가장 가까운 호스트의 ip주소를 할당하고
- 로드 밸런서가 api gateway 호스트로 요청을 보낸다
- api gateway는 캐싱 포함 여러 작업 수행

### 13.6.1 읽기: 다운로드

- 다운로드에서 다음 단계는 이 요청을 처리할 저장소 호스트를 선택하는 것
- 메타데이터 서비스는 이 과정을 지원
    - redis, sql 둘다 사용 가능
- 메타데이터는..
    - 파일을 포함하는 저장소 서비스 호스트
    - 각 데이터센터의 메타데이터 서비스는 호스트의 현재 부하를 추적
    - 호스트에서 파일을 다운로드하는 데 걸리는 시간 예측. 동일한 파일명 구분 (MD5, SHA 해시 사용)
    - 파일 소유권, 접근 제어
    - 호스트의 상태
- 다운로드 과정
    - 속도 제한 서비스를 통해 요청이 제한을 초과하는지 검사
    - 메타데이터 서비스에 쿼리해 이 자산을 포함하는 저장소 서비스 호스트를 가져옴
    - 저장소 호스트를 선택 → 자산을 클라이언트로 스트리밍
    - 저장소 호스트 부하 증가 → 메타데이터 서비스를 업데이트
- 그림 13.3 클라이언트가 cdn 다운로드를 수행하는 sequence diagram
- cdn에 자산이 없을 수 있음
    - 보존 기간이 지났거나
    - 저장공간 부족, 기타 오류 등으로 성공 업로드 됐다고 인식됐을 수 있음
    - 기타 오류
    - 그림 13.4
        - cdn에 자산이 없으면 백업 위치인 원본에서 다운로드 해야 됨
            - 지연 시간이 증가
        - 저장소 서비스에 업로드, 메타데이터 서비스 업데이트
            - 저장 프로세스는 자산 반환 작업과 병렬 수행 가능
- 저장시 암호화가 적용된 다운로드 과정
    - 그림 13.5
    - 암호화 키 인증이 필요한 비밀 관리 서비스에 저장
    - api gateway 호스트 초기화 될 때 비밀 관리 서비스로 인증하면 이 서비스에서 토큰을 호스트로 전달
    - 인가된 사용자가 자산을 요청

      → 비밀 관리 서비스에서 자산의 암호화 키를 얻음
      → 암호화된 자산을 복호화하여 사용자에게 반환

        - 여러 블록에 저장 된 경우 각 블록의 자산을 따로 복호화
    - 그림 13.6 cdn이 보유하지 않은 암호화된 자산을 가져오는 요청이 있을 때 발생하는 과정

### 13.6.2 쓰기: 디렉터리 생성, 파일 업로드, 파일 삭제

- 파일은 ID로 식별
    - 다른/동일 사용자가 같은 이름을 다른 파일에 사용할 수 있어 파일 이름을 식별자로 사용할 수 없음
- 멀티파트 업로드
    - 파일이 GB, TB 수준인 경우
    - 체크포인트, 벌크해드 like 프로세스를 개발해서 파일을 청크로 나눠야 함
    - 완료되지 않은 청크에 대해서만 업로드/다운로드 하면 됨
    - 청크 크기를 128mb 같이 고정할 수 있음
    - 클라이언트가 모든 청크를 다 업로드 하기 전에 중단하면
        - 주기적으로 불완전한 청크를 삭제하는 배치 etl 작업으로 공간 낭비 해소
- 모든 데이터 센터에 파일 사본을 유지하지 않기
    - 특정 파일은 특정 지역에서 사용될 수 있으므로
        - 특정 언어/오디오는 모든 데이터 센터에 사본을 포홤할 필요가 없다
- 배치 ETL 작업 재조정
    - 로깅 서비스에서 이전 기간 파일 다운 로그를 가져와 파일 요청 수를 확인하고
    - 이 숫자를 사용해 각 파일 저장소 호스트 수를 조정
    - 각 노드에 추가/삭제해야 할 파일의 맵을 만들고 셔플링을 수행
- 메타데이터 서비스에 새 파일 메타데이터를 쓰고, 그에 따른 저장소 서비스의 데이터 센터(클로스터 내부 접근) 또는 호스트(클러스터 외부 접근) 간에 파일을 셔플하는 접근 방식 설명
    - 그림 13.7 코레오그래피 사가 패턴 방식으로
        1. 셔플링 작업이 셔플링 토픽에 이벤트 생성
            1. 특정 위치에서 다른 위치로 파일을 이동하는 것에 해당
        2. 저장소 서비스가 이 이벤트를 소비하고 파일을 새 위치에 씀
        3. 저장소 서비스가 메타데이터 토픽에 이벤트 생성 → 메타데이터 서비스에 파일 위치 메타데이터 업데이트 요청
        4. 메타 데이터 서비스가 메타데이터 토픽 소비하고 파일 위치 메타 데이터를 업데이트
        5. 메타데이터 서비스가 파일 삭제 토픽에 이벤트 생성 → 저장소 서비스에 이전 위치로부터 파일 삭제 요청
        6. 저장소 서비스가 이 이벤트를 소비하고 이전 위치로부터 파일 삭제
    - 그림 13.8 메타데이터 서비스가 오케스트레이터인 오케스트레이션 사가 패턴 접근 방식
        1. 메타데이터 서비스가 이 이벤트를 소비
        2. 메타 데이터 서비스가 파일 생성 토픽에 이벤트를 생성해 저장소 서비스에 새 위치에 파일 생성 요청
        3. 저장소 서비스가 이 이벤트를 소비해 파일을 새 위치에 씀
        4. 저장소 서비스가 응답 토픽에 이벤트를 생성해 메타데이터 서비스에 파일 쓰기가 성공적으로 완료됐음을 알림
        5. 메타데이터 서비스가 이 이벤트를 소비
        6. 메타 데이터 서비스가 파일 삭제 토픽에 이벤트 생성, 저장소 서비스에 이전 위치에서의 파일 삭제 요청
        7. 저장소 서비스가 이 이벤트를 소비하고 이전 위치에서 파일 삭제

## 13.7 캐시 무효화

파일 핑거 프린트..

## 13.8 로깅, 모니터링, 경보

- 업로더가 파일의 업로드 진행중 상태 추적 가능
- cdn 미스를 기록, 모니터링
- fe 서비스가 파일 요청 속도를 기록
- 비정상적/악의적 확동 모니터링

## 13.9 미디어 파일 다운로드에 대한 기타 가능한 논의

- 미디어 파일을 완전히 다운로드 하기 전에 재생할 수 있기를 바랄 수 있다
    - 미디어 파일을 더 작은 파일로 나눔
    - 부분 버전을 재생하면서 조립을 수행할 수 있는 클라이언트 사이드의 미디어 플레이어가 필요
    - 순서가 중요하므로 다운로드할 파일을 나타내는 메타데이터가 필요
-