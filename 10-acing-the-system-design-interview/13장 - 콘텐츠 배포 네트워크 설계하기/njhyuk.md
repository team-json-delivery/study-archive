# 13장 콘텐츠 배초 네트워크 설계하기
## 13.1 CDN의 장단점
### 13.1.1 CDN 사용의 장점
* 낮은 지연시간
* 확장성
* 낮은 단위 비용
* 높은 처리량
* 높은 가용성
### 13.1.2 CDN 사용의 단점
* 복잡성
  * 추가적인 실패 지점
  * 추가적인 DNS 조회
* 트래픽이 적은 경우 높은 단위 비용
* 다른 CDN으로 마이그레이션 하는데 드는 비용
* 일부 국가에서 특정 CDN 차단
* 서드파티에 저장하는 것이 보안과 프라이버시 우려
* 자바스크립트 라이브러리에 악성코드 삽입
* CDN의 기술적 문제에 대해 CDN 회사의 해결속도
### 13.1.3 이미지 제공 CDN을 사용할때 발생할 수 있는 예상치 못한 문제의 예
* CDN에서 자동으로 WebP 형식으로 변환하기도 함
* 원본으로 바꾸고 싶을때
  * User-Agent 재정의하는법
    * 크롬에서는 불가능한 문제
  * 특정 서비스에서는 WebP, 다른서비스에서는 원본 이미지
    * CDN에서 지원하지 않을 수 있음
  * 요청을 백엔드 서비스를 통해 라우팅
    * CDN의 이점 무효화
## 13.2 요구사항
* 기능 요구사항
  * 권한이 있는 사용자는 디렉토리를 만들고
  * 10GB 크기 제한으로 파일 업로드, 다운로드 가능해야함
* 비기능 요구사항
  * 확장성
  * 고가용성
  * 고성능
  * 내구성
  * 보안과 프라이버시
## 13.3 CDN 인증과 권한 부여
* 인증의 목적은 사용자를 식별
* 인가의 목적은 CDN 파일에 접근하는 사용자가 리소스 권한을 가지고 있는지 확인
* 인증/인가로 핫링킹을 방지해야함
  * 사이트나 서비스 허가 없이 CDN 자산에 접근
* 인증과 권한 부여는 쿠키 기반 인증이나 토큰 기반 인증으로 할 수 있다.
### 13.3.1 CDN 인증과 권한 부여 단계
CDN은 각 사용 업체에 비밀 키를 발급하고 토큰을 생성하는 SDK나 라이브러리를 제공
* 사용자가 CDN에 인증 요청을 보낸다
* CDN 사용 업체 앱이 SDK를 사용해 다음 입력으로 접근 토큰을 생성한다
  * 비밀키
  * CDN URL
  * 접근 토큰의 만료 타임트램프
  * 리퍼러
  * 허용된 IP
  * 허용된 국가나 지역
* 고객 앱이 토큰을 저장한 후 이 토큰을 사용자에게 반환한다
* 고객 앱이 사용자에게 CDN URL을 제공할 때 마다 GET 요청에는 접근 토큰으로 서명해야 한다
* 사용자가 로그아웃 하면 고객 앱은 사용자의 토큰을 파기한다
### 13.3.2 키 교체
해커가 키를 훔치더라도 키가 변경될떄 까지만 유용하도록 키를 주기적으로 변경해야함
## 13.4 상위 수준 아키텍처
* API 게이트웨이
  * 속도 제한 서비스
  * 메타 데이터 서비스
  * 스토리지 서비스
  * 원본
  * 비밀 관리 서비스
  * 로깅 서비스
## 13.5 저장소 서비스
* 파일 포함하는 호스트/노드의 클러스터
* 파일은 DB에 저장하면 안됨, 호스트의 파일 시스템에 저장해야함
* 가용성과 내구성을 위해 파일 복제, 각 파일을 여러 호스트에 할당
### 13.5.1 클러스터 내부
* 주키퍼를 클러스터 내부 관리자로 포함하는 HDFS와 같은 분산 파일시스템을 사용할 수 있다.
* 주키퍼는 리더 선출을 관리하고 파일,리더, 팔로워 간의 매핑을 유지한다.
### 13.5.2 클러스터 외부
* 여러 데이터 센터에 분산된 3개 이상의 노드로 구성
* 파일을 읽거나 쓰려면 메타데이터 서비스가 파일이 저장돼 있거나, 저장돼야 할 클러스터를 식별한 다음 클러스터에서 무작위로 선택한 노드에서 파일을 읽거나 쓴다.
## 13.6 일반적인 작업
* 클라이언트가 IP 주소 대신 CDN 서비스의 도메인으로 요청하면 GeoDNS가 가까운 호스트이 IP 주소를 할당, 여기서 로드 밸런서가 API 게이트웨이 호스트로 요청을 보낸다
### 13.6.1 읽기: 다운로드
* 다운로드에서 다음 단계는 이 요청을 처리할 저장소 호스트를 선택하는것
* 메타데이터 서비스는 다음과 같은 메타데이터를 유지하고 제공함으로써 이 선택 과정을 지원, 레디스나 SQL 둘다 사용할 수 있다
#### 다운로드 과정
* 속도 제한 서비스를 통해 클라이언트 요청이 제한을 초과하는지 검사
* 메타데이터 서비스에 쿼리, 이 자산을 포함하는 저장소 서비스 호스트를 가져옴
* 저장소 호슽를 선택하고 자산을 클라이언트로 스트리밍
* 저장소 호스트의 부하 증가로 메타데이터 서비스를 업데이트
#### 저장시 암호화가 적용된 다운로드 과정
* 자산을 암호화된 형태로 저장해야 하는 경우 암호화 키 인증이 필요한 비밀 관리 서비스에 저장
* 인가된 사용자가 자산을 요청할 때 호스트는 먼저 비밀관리 서비스에서 자신의 암호화 키를 얻음
* 저장소 서비스에서 암호화된 자산을 가져와 복호화 하고 사용자에게 반환
### 13.6.2 쓰기
* 파일은 내용이 아닌 ID로 식별
  * ID는 다르지만 내용이 같은 파일은 다른 파일
* 소유자가 다르지만 같은 파일은 따로 저장해야 하는가? -> 파일중복제거는 복잡성 증가 트레이드 오프
* 파일 크기가 GB나 TB수준이면 업로드나 다운로드중 실패 할 수 잇음
  * 체크포인팅이나 벌크헤드와 유사한 프로세스를 개발해 파일을 청크로 나눠야함
  * 멀티파트 업로드라고 함
* 불완전 업로드
  * 클라이언트가 모든 청크를 업로드하기 전에 업로드 중단, 공간 차지
  * ETL로 제거 필요
#### 모든 데이터 센터에 파일 사본을 유지하지 않기
주로 특정 지역에서만 사용되는 파일일 수 있으니 모든 데이터 센터에 사본을 포함할 필요는 없다
#### 배치 ETL 작업의 재조정
* 다양한 데이터 센터에 파일을 분산하고 수요를 충족하기 위해 복제하는 주기적 배치 작업 필요
* 다운로드 로그 - 파일 요청수 확인 - 파일 저장소 호스트 수 조정
* 파일 위치와 접근을 지속적으로 분석하고 파일 재분배 (셔플링 작업)
  * 메타데이터 서비스는 저장소 서비스로부터 파일이 새 위치에 성공적으로 기록됐다는 성공 응답을 받았을 때만 메타데이터를 업데이트 해야 한다.
  * 코레오그래피, 오케스트레이션 사가 패턴으로 접근하여 해결할 수 있다.
## 13.7 캐시 무효화
* CDN은 주로 정적파일이라 캐시무효화는 덜 중요하기도 함
* 파일에 핑거 프린트를 남길 수 있음
## 13.8 로깅, 모니터링, 경보
* 업로더가 파일의 업로드 진행중 완료나 실패 상태 추적
* CDN 미스를 기록하고 모니터링하며 낮은 긴급도 경보를 트리거
* 프론트엔드 서비스가 파일의 요청 속도 기록
* 비정상적 활동 모니터링
## 13.9 미디어 파일 다운로드에 대한 기타 가능한 논의
* 미디어 파일을 완전히 다운로드 하기 전에 재생하고 싶을 수 있음
* 미디어 파일을 더 적은 파일로 나누기
* 순서대로 다운로드, 부분 버전인 미디어 파일로 조립
* 부분 버전을 재생, 조립을 수행할 수 있는 클라이언트 필요
