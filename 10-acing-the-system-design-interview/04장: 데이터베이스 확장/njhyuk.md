# 4장: 데이터베이스 확장
## 4.1 저장 서비스의 이해
* 저장 서비스는 상태 저장 서비스다
  * 일관성을 보장하기 위한 매커니즘이 있으며, 손실을 막기 위해 복제가 필요함
* 가능한 모든 서비스를 상태 비저장으로 만들어야함
  * 상태 저장 서비스는 일관성, 복잡성, 보안, 지연시간, 성능 등 다양한 트레이드 오프 결정 필요
  * 백엔드가 상태 저장이면 고정 세션을 구현해야함
* 스토리지 분류
  * 데이터베이스
    * SQL
    * NoSQL
    * Column-oriented
    * Key-value
  * Document
  * Graph
  * File Storage
  * Block Storage
  * Object Storage
## 4.2 데이터베이스 사용 결정
* 서비스의 데이터 저장 방법을 결정할때 DB외에 파일,블록, 객체 스토리지를 사용할지 논의할 수 있음
* 다양한 접근 방식과 트레이드 오프를 논의해야함
## 4.3 복제 
* DB를 확장하는 방법은 복제, 분할, 샤딩이다
* 읽기 연산을 확장하려면 복제본 수를 늘리면 된다
  * 쓰기 확장은 더 어렵다
### 4.3.1 복제본 분산
* 일반적인 설계
  * 같은 랙의 호스트에 하나의 백업을 두고, 다른 랙이나 데이터 센터 둘다에 있는 호스트에 또 다른 백업을 두기
* 데이터는 샤딩 될 수 있음, 샤딩의 주요 트레이드 오프는 샤드 위치 추적하는 복잡성 증가
### 4.3.2 단일 리더 복제
* 단일 리더 복제에서는 모든 쓰기 작업이 리더라고 하는 단일 노드에서 발생
  * 단일 리더 복제는 쓰기가 아닌 읽기 확장에 관한 것
* SQL 서비스는 ACID 일관성을 잃는다, 트레이드 오프
* 단일 노드는 팔로워와 공유할 수 있는 처리량에 제한, 팔로워의 최대 수를 제한함
  * 읽기 확장성을 제한함
    * 더 확장하려면 다중 수준 복제를 사용 (피라미드), 일관성 지연
* MySQL binlog 기반 복제는 단일 리더 복제의 예
#### 단일 리더 복제를 확장하기 좋은 방법: 애플리케이션 계층의 쿼리 로직
* 데이터베이스 크기를 줄일수 없지만 SQL을 계속 사용하고 싶다면, 데이터를 여러 SQL 데이터베이스로 나누는 방법
  * 애플리케이션에서 결과를 결합해야함
  * 이는 본질적으로 애플리케이션에 메타데이터 관리가 있는 다중리더 복제
### 4.3.3 다중 리더 복제
* 여러 노드가 리더로 지정, 모든 리더에서 쓰기를 수행
  * 각 리더는 자신의 쓰기 내용을 다른 모든 노드에 복제해야 함
* 일관성 문제와 접근 방식
  * 일관성문제와 경쟁 조건 문제가 발생함
  * 한 리더에서 행을 업데이트 하는 동안 다른 리더에서 행을 삭제
* 일반적으로 일관성 요구사항을 유연하게 조정할 방법을 찾아야 함
  * 모든 사용자에 대해 일관성을 유지해야 하는 데이터의 양을 최소화하는 접근 방식을 찾아야 함
### 4.3.4 리더 없는 복제
* 모든 노드가 동등, 읽기와 쓰기는 어느 노드에서나 일어날 수 있음
* 경쟁조건 처리방법
  * 정족수 합의를 위해 동의해야 하는 최소 노드 수
* 빠른 쓰기 vs 빠른 읽기
  * 빠른 쓰기가 필요하다면 낮은 쓰기 정족수와 높은 일관수
  * 빠른 읽기는 그 반대
* 카산드라, 다이나모에서 사용
### 4.3.5 HDFS 복제
* HDFS클러스터는 
  * 활성 네임노드
  * 수동(백업) 네임노드
  * 여러 데이터 노드로 구성된다
* HDFS는 추가 작업만 함, UPDATE나 DELETE 작업을 지원하지 않음
  * INSERT는 경쟁 조건이 없다
## 4.4 샤딩된 데이터베이스로 저장 용량 확장하기
* DB 크기가 단일 호스트 용량을 초과하면 오래된 행을 삭제해야함
  * 보존해야 하면 HDFS나 카산드라 같은 샤딩된 스토리지에 저장
* 샤딩은 호스트를 추가하는 것 만으로 무한 수평확장
### 4.4.1 샤딩된 RDBMS
* JOIN 쿼리가 훨씬 느려진다.
  * JOIN 쿼리는 각 노드 사이 상당한 네트워크 트래픽
* 집계 작업에는 데이터베이스와 애플리케이션이 모두 관여
  * 중앙값이나 백분위수 같은 특정 집계 작업은 복잡하고 느림
## 4.5 이벤트 집계하기
* 샘플링과 집계는 DB 쓰기 빈도를 줄이는 기법
* 이벤트 집계는 여러 이벤트를 단일 이벤트로 집계/결합
  * 여러번의 DB 쓰기 대신 단 한번의 DB 쓰기만 발생
* 집계는 스트리밍 파이프라인을 사용해 구현할 수 있다
> 카프카 이벤트가 너무 많으면 샘플링/집계 하는 방법도 있겠다
### 4.5.1 단일 계층 집계
* 집계는 단일 계층이나 다중 계층으로 이뤄질 수 있다.
* 각 호스트는 메모리에 해시테이블을 갖고 있어 해당 테이블에서 개수를 집계할 수 있다.
  * 주기적으로 DB에 기록
### 4.5.2 다중 계층 집계
* 이전 계층의 상위 호스트로부터 이벤트 집계
* 집계의 주요 트레이드오프는 최종 일관성과 복잡성
### 4.5.3 분할
* 이벤트가 A-Z 면 특정 호스트로 분할, 이벤트라 S-Z면 다른 특정 호스트로 분할 할 수 있따
* 특정 파티션이 불균형적으로 높은 트래픽을 받을 수 있다
### 4.5.4 대규모 키 공간 처리하기
* 첫번째 계층의 두 호스트는 실제로 수용할 수 있는 양의 절반으로 키 공간 제한
  * 그래야 두번째 계층의 호스트가 모든 키를 수용할 수 있음
### 4.5.5 복제와 내결함성
* 호스트가 다운되면 모든 이벤트를 잃는다
* 각 노드를 레디스에 요청을 보내는 여러 상태 비저장 노드 클러스터로 전환하는 방법
## 4.6 배치와 스트리밍 ETL
### 4.6.1 간단한 배치 ETL 파이프라인
* 간단한 배치는 크론탭으로 구현 가능 
  * 확장성이 없음, 단일 호스트에서 실행됨
    * 단일 장애 지점
    * 리소스가 없을 수 있음
    * 호스트 용량 초과 가능성
  * 실패할때 멱등성을 제공하지 않음
### 4.6.2 메시징 용어
* 메시징 시스템
* 메시지큐
* 발행자/구독자
* 메시지 브로커
* 이벤트 스트리밍
* 풀과 푸시
  * 일반적으로 풀이 푸시보다 낫다
  * 풀에서는 구독자가 메시지 소비 속도를 제어하므로 과부화되지 않는다
### 4.6.3 카프카와 RabbitMQ
* 면접에서는 선입견이 있는 면접관의 신경을 거스릴 위험을 감수하기보다는 카프카와 RabbitMQ의 세부사항과 차이점에 관한 지식을 보여주고 트레이드오프를 논의하는 것이 더 안전함
* 카프카는 항상 RabbitMQ 대신 활용될 수 있지만 그 반대는 아니다
### 4.6.4 람다 아키텍처
* 배치와 스트리밍 파이프라인을 병렬로 실행해 빅데이터를 처리하는 데이터 처리 아키텍처
* 빅데이터를 다루고 일관성과 정확성이 필요하면 람다 아키텍처 제안 가능
## 4.7 비정규화
JOIN 쿼리를 피하기 위해 스키마를 비정규화해 저장 공간을 속도와 맞바꾸는 방법
## 4.8 캐싱
### 4.8.1 읽기 전략
* 캐시 어사이드
  * 캐시 Miss 되면 **애플리케이션이** 데이터 베이스에 읽기 요청 후 캐시에 쓰기
  * 캐시미스가 있는 요청은 DB에 직접 요청하는것 보다 느리다
* 읽기 통과
  * 캐시 미스가 발생하면 **캐시가** DB에 요청하고 캐시에 쓰기
### 4.8.2 쓰기 전략
* 쓰기 통과 방식
  * 모든 쓰기 작업은 캐시를 거쳐 데이터베이스로 전달
  * 캐시와 DB 양쪽으로 써서 쓰기 속도가 느리다
  * 대부분의 데이터는 읽히지 않으므로 불필요 비용이 발생한다
* 지연 쓰기/후속 쓰기 방식
  * 캐시는 주기적으로 갱신된 데이터를 데이터베이스에 플러시 한다
  * 설계가 복잡해지는 단점
  * 재고를 레디스로 관리하는 사례 https://techblog.woowahan.com/2709/
* 쓰기 우회 방식
  * 애플리케이션은 DB에만 기록한다
  * 캐시 미스가 발생할 때 캐시를 갱신한다
## 4.9 독립 서비스로서의 캐싱
서비스 호스트의 메모리에 캐시하지 않는 이유
* 서비스는 상태 비저장, 각 요청은 무작위로 호스트에 할당, 특정 요청에 캐시된 데이터가 있을 가능성이 낮다
* 호스트에 캐시하면 서비스 배포마다 캐시가 삭제된다
* 많은 클라이언트가 동시에 캐싱 미스 요청을 보내면 DB가 같은 쿼리를 여러번 실행한다
> 자주 변화하지 않는 데이터면 로컬 캐시 고려
>  [분산 시스템에서 로컬 캐시 활용하기 | 카카오페이 기술 블로그](https://tech.kakaopay.com/post/local-caching-in-distributed-systems/)
## 4.10 캐시할 수 있는 다양한 종류의 데이터와 캐싱 방법 예시
* 캐시하지 말아야 할 정보
  * 개인정보
  * 실시간 공개 정보 (주식 가격, 항공기 도착 시간)
  * 유료 저작권 콘텐츠
  * 변경될 수 있는 공개 정보는 캐시할 수 있지만, 백엔드에 재검증 해야함
* 오랫동안 변경되지 않을 공개 정보
  * 긴 캐시 만료 시간으로 캐시 (기차 시간표)
* 데이터를 클라이언트 기기에 저장하는 방법 (카카오톡)
## 4.11 캐시 무효화
### 4.11.1 브라우저 캐시 무효화
* 핑거 프린팅 기법
  * image.png?hash=sfsdf33
* max-age 설정 방법
  * HTML, CSS, 자바스크립트 모두 캐시하고 동일한 max-age 설정하기
### 4.11.2 캐싱 서비스의 캐시 무효화
* 무작위 교체 : 캐시가 가득 찼을때 무작위 항목 교체
* 최근 최소 사용 : 가장 최근에 사용된 항목 교체
* 선입선출 : 추가된 순서대로 항목 교체
* 후입선출 : 추가된 역순으로 교체
## 4.12 캐시 워밍
* 첫 요청 전에 캐시를 미리 채우기
* 단점
  * 수천개의 호스트라면 복잡하고 비용이 많이 드는 과정
  * 캐시 워밍 과정에 DB 부하
  * 캐시없는 첫 요청만 느린데, 워밍을 도입할 필요가 있는지 검토
  * 캐시 만료 시간이 짧으면 캐시 워밍이 시간낭비
