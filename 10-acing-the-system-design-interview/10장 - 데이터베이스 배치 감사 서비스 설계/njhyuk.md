# 10장 : 데이터베이스 배치 감사 서비스 설계
## 10.1 감사는 왜 필요한가?
* 배치 감사가 백업을 하지 않는 관행을 조장할 수 있다고 주장할 수 있다.
  * 예를 들어 백업되지 않은 DB에서 데이터 손실로 인해 데이터가 유효하지 않은 상황
  * 데이터를 잃는 대신 복제나 백업을 구현해야함
  * 백업은 몇초 이상 걸릴 수 있음
  * 백업되기전에 리더호스트가 실패할 수 있음
    * 리더호스트가 복구되면 데이터가 복구되어 다른 호스트로 복제될 수 있음
    * 그러나 MongoDB 의 경우 문제, 쓰기 우려가 1로 설정되면 모든 노드가 일관성을 가져야함
    * 리더 노드 쓰기가 성공했지만 복제가 발생하기 전 리더 노드가 실패하면 다른 노드는 새 리더를 선택함
    * 이전 리더 노드가 복구되면 이러한 쓰기를 포함한 새 리더 노드와 다른 모든 데이터를 롤백함
* 서비스가 데이터를 받을때 유효성 검사를 하면, 감사가 필요 없다고 주장할 수 있다.
  * 그러나 저자는 감사가 없어 5년간 잘못된 데이터가 있던 경우가 있었음
    * 유효성 검사가 서비스 오픈 이후 한달 이후에 개발되었던 문제
* 배치 감사만으로 찾을수 있는 문제가 있다.
  * 일부 유효성 검사는 이전에 수집된 데이터가 필요할 수 있음. (비교)
## 10.2 SQL 쿼리 결과에 대한 조건문으로 유효성 검사 정의 
* 쿼리로 다양한 유효성 검사 코드 예시.. 책 참조
* 제약조건중 일부는 ORM 라이브러리로 구현될 수 있다
  * @NotNull
  * @Length(min = 0, max= 255)
## 10.3 간단한 SQL 배치 감사 서비스
### 10.3.1 감사 스크립트
가장 간단한 형태의 배치 감사 작업은 다음 단계를 수행하는 스크립트임
* 데이터베이스 쿼리를 실행한다
* 결과를 변수로 읽는다
* 이 변수의 값을 특정 조건과 비교한다
### 10.3.2 감사 서비스
* 위 스크립트를 배치 감사 서비스로 확장하기
* 배치 감사 작업은 두단계로 나뉨
  * 쿼리를 실행하고 그 결과를 사용해 감사 통과 여부 결정
  * 감사가 실패하면 경보를 트리거
## 10.4 요구사항
* 감사작업의 CRUD, 감사 작업은 다음 필드를 포함한다
  * 사용자 지정 시간 등의 간격
  * 소유자
  * 유효성 검사 데이터베이스 쿼리
  * SQL 쿼리 결과 조건문
* 실패한 작업은 경보를 발생시켜야 한다
* 과거와 현재 실행중인 작업의 로그를 볼 수 있어야 한다
* 감사 작업은 최대 6시간 이내에 완료되어야 한다
* 데이터베이스 쿼리는 15분 이내에 완료되어야 한다
* 비기능적 요구사항
  * 스케일 : 만개 미만의 작업이나 만개미만의 문(Statement)이 있을것으로 예상한다
  * 가용성 : 고가용성은 필요하지 않다
  * 보안 : 작업에는 접근 제어가 있다
  * 정확성 : 감사 작업 결과는 정확해야 한다
## 10.5 고수준 아키텍처
* 사용자 -> UI -> 백엔드 -> 배치 ETL 서비스 -> 경보 서비스
* 사용자는 공유 배치 ETL 서비스에 요청하여 작업의 상태 및 이력 확인을 포함하여 배치 감사 작업을 CRUD 한다
* 공유 배치 ETL 서비스는 경보 서비스가 아니므로 경보를 트리거 하거나 경보의 상태와 기록을 보기위한 API 엔드포인트가 없다. 경보 서비스에 직접 요청 해야한다.
> 젠킨스 -> 스프링배치로 간단하게 만드는게 낫지 않을까?.. 읽다보니 배치 아키텍처 구축기구나
### 10.5.1 배치 감사 작업 실행
감사 작업은 구성된 시간 간격으로 주기적으로 실행되며, 두가지 주요 단계가 있다.
1. 데이터베이스 쿼리를 실행한다
2. 데이터베이스 쿼리 결과로 조건문을 실행한다
### 10.5.2 경보 처리
* 두 구성요소
  * 경보 트리거 요청은 배치 ETL 서비스에서 이루어진다.
  * 경보 상태 및 기록 조회 요청은 백엔드 서비스에서 이루어진다.
* 경보서비스에 연결하기 위한 구성을 두 서비스에서 해야함
  * 백엔드에서만 이루지게 할 수 있다.
  * 단, 잠재적인 버그를 유발할 수 있다. (백엔드 서비스에 문제가 있을때 안보내짐)
  * 대안
    * 배치 ETL 서비스는 분할된 카프카 토픽으로 생성
    * 백엔드 서비스 호스트는 이러한 파티션에서 소비하고 각 파티션에서 체크포인트 수행
    * 그러나 이렇게 하면 백엔드 서비스가 알림 요청을 한 후 체크포인트 전에 실패, 중복 알림이 발생할 수 있다
## 10.6 데이터베이스 쿼리 제약
* 배치 ETL 서비스는 실행할 수 있는 쿼리의 속도와 기간에 제약을 받아야 한다.
  * 전반적인 지연시간을 증가 시킨다
  * 비싸고 오래 실행되는 쿼리는 비용기 많이 든다
  * 쿼리 일정 내에 실행 될 수 있어야 한다
### 10.6.1 쿼리 실행 시간 제한
소유자가 작업 구성을 생성하거나 편집할때는 쿼리 실행 시간을 10분으로 제한하고, 작업이 실행 중일때는 15분으로 제한한다.
### 10.6.2 제출 전 쿼리 문자열 확인 
* 10분 뒤에 거부되었다고 알리는 대신 사전 유효성 검증하기
  * 전체 테이블 스캔 비허용
  * 파티션 키가 포함된 테이블에서만 쿼리 실행하게 하기
  * 쿼리에 파티션 키 필터 포함되게 하기
    * 파티션 키를 확인하기 위해선 DESCRIBE 쿼리 실행해서 확인
### 10.6.3 초기 사용자 훈련
제약 조건을 안내하는 좋은 UX와 유익한 문서 안내 
## 10.7 과도한 동시 쿼리 방지
배치 ETL 서비스가 실행할 수 있는 동시 쿼리 수에 제한 설정
## 10.8 데이터베이스 스키마 메타데이터의 사용자
* 사용자의 쿼리 작성을 돕기 위해 서비스는 스키마 메타데이터에서 작업 구성을 자동으로 도출 할 수 있다
  * where 필터를 작성할때 UI는 이러한 열을 제안하는 쿼리 템플릿 제시
  * 조직의 메타데이터 카탈로그/플랫폼을 개발할 수 있다
> 전회사에서 메타데이터를 관리하는 곳 한곳 있었음.. 다른곳도 쓰시는곳 있는지?
## 10.9 데이터 파이프라인 감사
특정 감사 작업이 실패하면 서비스는 다음을 수행해야 한다.
* 상위 작업이 실패하면 하위 감사 비활성화
* 이 테이블 쿼리를 포함하는 다른 작업과 그 하위 작업 비활성화
* 소유자에게 경보 트리거
이 테이블에 문제가 있음을 메타데이터 플랫폼에 업데이트 -> 다른 작업도 비활성화
## 10.10 로깅, 모니터링, 경보
다음 항목을 모니터링 하고 경보를 보내야 함
* 시작, 진행중, 성공, 실패, 시간
* 쿼리 시간 초과나 쿼리 실행 오류같은 실패 이유
* 쿼리 실행시간 오버
* 상위 작업 실패
* 높은 CPU, 메모리나 사용율
* 백엔드 4xx, 5xx 응답
## 10.11 기타 감사 가능 유형
* 데이터센터간 일관성 검사
* 업스트림과 다운스트림 데이터 비교
