# Chapter 5: Distributed Transactions

## 1. 개요 및 문제 배경

- 분산 시스템에서는 하나의 작업 단위가 여러 서비스에 데이터를 저장해야 함.
- 일부 쓰기 작업이 실패할 경우 **데이터 불일치** 발생.
- 예시:
    - 투어 패키지 예약 시 항공권, 호텔, 결제 서비스에 각각 쓰기 필요.
    - 하나라도 실패 시 전체 예약 실패, 혹은 불일치 상태 발생.

## 2. Event-Driven Architecture (EDA)

- **정의**: 작업 요청이 아닌, 발생한 이벤트를 발행하고 비동기적으로 처리하는 구조.
- **장점**:
    - 느슨한 결합
    - 비차단(Non-blocking)
    - 고확장성, 저지연성
- **단점**:
    - 메시지 누락/지연 처리에 대한 추가 설계 필요
    - 복잡한 트래픽 상황에서 재처리 로직 필요
- **실용적 적용**:
    - 입력값 유효성 검증 등 일부 동기 처리 허용
    - 이벤트 기반 아키텍처로 확장성 확보

## 3. Event Sourcing

- **정의**: 상태 변경을 나타내는 이벤트를 append-only 로그에 저장.
- **구성 요소**:
    - 이벤트 로그가 **단일 진실의 원천(source of truth)**
    - DB들은 로그의 projection
- **장점**:
    - 감사, 디버깅 가능 (과거 상태 재현)
    - 새로운 이벤트 핸들러로 비즈니스 로직 유연 확장
- **단점**:
    - 설계 복잡성 증가 (스키마 진화, 이벤트 재생)
    - 저장 비용 증가

## 4. Change Data Capture (CDC)

- **정의**: DB의 트랜잭션 로그를 기반으로 이벤트 스트림을 생성하여 다른 서비스에 전달.
- **예시 도구**:
    - Debezium, DynamoDB Streams, Eventuate CDC 등
- **장점**:
    - 거의 실시간 데이터 반영
    - 기존 DB 유지 가능
- **단점**:
    - 중복 이벤트 발생 가능 → Idempotent 처리 필요
    - 이벤트는 진실의 원천이 아님 (DB가 원천)

## 5. Event Sourcing vs CDC

| 항목 | Event Sourcing | CDC |
|------|----------------|-----|
| 목적 | 이벤트 로그가 진실의 원천 | 데이터 동기화 |
| 원천 | 이벤트 로그 | 데이터베이스 |
| 이벤트 유형 | 상태 변경 이벤트 | DB row-level 변경 |

## 6. Transaction Supervisor

- 실패하거나 누락된 트랜잭션을 검토 및 보상 처리하는 프로세스
- **형태**:
    - 수동 인터페이스 → 자동화 배치 혹은 서버리스 함수
- **주의점**:
    - 다른 트랜잭션 메커니즘과 중첩 금지
    - 보상 트랜잭션은 항상 로깅해야 함

## 7. Saga Pattern

- 하나의 트랜잭션을 여러 **로컬 트랜잭션**으로 나눠 실행
- 모두 성공하거나, 실패 시 **보상 트랜잭션**으로 롤백
- 보상/피벗/재시도 트랜잭션 개념 존재
- Kafka 등 브로커를 통한 서비스 간 비동기 통신 사용

### 7.1 Choreography

- **정의**: 각 서비스가 서로 이벤트를 주고받아 사가를 구성
- **특징**:
    - 병렬 처리 → 빠른 응답
    - 구조가 복잡해지기 쉬움
- **장점**:
    - 낮은 지연, 네트워크 부하 적음
    - SPOF 없음
- **단점**:
    - 전체 흐름 파악 어려움
    - 서비스 간 강결합 가능성
- **설계 시 주의사항**:
    - 다대다 토픽-서비스 관계 지양
    - 이벤트 저장소를 통한 상태 추적 필요

### 7.2 Orchestration

- **정의**: 중앙의 오케스트레이터가 전체 트랜잭션을 제어
- **특징**:
    - 직렬 처리 → 명확한 흐름 추적 가능
    - 오케스트레이터가 단일 장애점이 될 수 있음
- **장점**:
    - 이해 및 유지보수가 용이
    - 각 서비스가 독립적으로 개발 가능
- **단점**:
    - 이벤트 수 증가 → 리소스 소비 증가
    - 고가용성 요구됨 (오케스트레이터 포함)

### 7.3 비교

| 항목 | Choreography | Orchestration |
|------|--------------|----------------|
| 구조 | Observer 패턴 (분산형) | Controller 패턴 (중앙집중형) |
| 흐름 | 병렬 | 직렬 |
| 유지보수 | 어려움 | 용이 |
| 지연 시간 | 낮음 | 높음 |
| 리소스 소비 | 적음 | 많음 |
| 장애 허용성 | SPOF 없음 | SPOF 있음 (오케스트레이터) |
| 보상 방식 | 각 서비스가 수행 | 오케스트레이터가 수행 |

## 8. 기타 합의 알고리즘 (별도 참고)

- Quorum writes
- Paxos / EPaxos
- Raft
- Zab (ZooKeeper)

> 참고 문헌: *Designing Data-Intensive Applications* (Martin Kleppmann)

## 9. 결론 요약

- 분산 트랜잭션은 여러 서비스의 정합성을 유지하기 위한 핵심 설계 이슈.
- **Event Sourcing**은 이벤트 로그 기반 시스템 상태 재생 가능.
- **CDC**는 기존 DB 기반의 실시간 이벤트 전파에 적합.
- **Saga**는 실패 대응을 위한 트랜잭션 시퀀스 패턴.
    - Choreography: 병렬 + 낮은 지연 + 복잡성 높음
    - Orchestration: 중앙 제어 + 유지보수 용이 + 지연/리소스 비용 큼
