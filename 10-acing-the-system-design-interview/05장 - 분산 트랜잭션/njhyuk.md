# 5장: 분산 트랜잭션
* 분산트랜잭션은 별개의 쓰기 요청을 하나의 분산된(원자적) 트랜잭션으로 결합한다.
* 합의라는 개념을 소개한다.
  * 모든 서비스가 쓰기 이벤트가 발생했거나 발생하지 않았다는것에 동의하는것
## 5.1 이벤트 기반 아키텍처
* EDA는 비동기적이고 논 블로킹 방식 
  * 이벤트를 발행하기만 하면 서버는 성공 응답 반환
  * 이벤트는 그 후에 처리
* 느슨한 결합, 확장성, 응답성을 강화함
* EDA의 대안은 다른 서비스를 직접 호출
  * 이는 다른 서비스의 장애가 전파되어 좋은 방법은 아님
## 5.2 이벤트 소싱
* 추가 전용 로그에 이벤트로 데이터나 데이터 변경을 저장하는 패턴
* 시스템의 모든 이벤트에 대한 완전한 감사 추적 제공
* 디버깅이나 분석을 위한 이벤트를 다시 실행, 시스템의 과거상태에 대해 이해할 수 있게 해줌
* 시스템에 복잡성이 더해지고 저장 요구사항이 증가함, 복원에 비용이 계속 증가함
## 5.3 변경 데이터 캡처 (CDC)
* 데이터 변경 이벤트를 변경 로그 이벤트 스트림에 기록
* 변경 로그 이벤트에 발행, 여러 소비자는 이벤트를 소비, 다운 스트림 서비스에 제공
* CDC는 이벤트 소싱보다 일관성이 높고 지연 시간이 낮다
## 5.5 트랜잭션 감독자
* 트랜잭션이 성공적으로 완료되거나 취소되게 보장하는 프로세스
* 주기적인 배치작업이나 서버리스 함수로 구현할 수 있다
* 불일치 수동검토나 보상 트랜잭션의 수동 실행을 위한 인터페이스로 먼저 구현되어야 한다
  * 보상 트랜잭션을 자동화하는 것은 신중해야함
## 5.6 사가 패턴
모든 트랜잭션이 성공적으로 완료돼야 하며, 그렇지 않으면 보상 트랜잭션 실행
### 5.6.1 코레오그래피 방식
* 사가패턴을 시작하는 서비스는 두개의 카프카 토픽과 통신
  * 분산트랜잭션 시작 - 하나의 카프카 토픽에서 생성
  * 최종 로직을 수행 - 다른 카프카 토픽에서 소비
* 호텔 예약서비스 예시
  1. 예약 요청 - 예약토픽에 예약 요청 이벤트 생성
  2. 예약 요청 이벤트 소비
     * 티켓서비스와 호텔 서비스가 이 예약 요청 이벤트 소비
  3. 티켓 서비스와 호텔서비스
     * 각각 티켓토픽과 호텔 토픽에 결제 요청 이벤트 생성
  4. 결제서비스
     * 티켓토픽과 호텔 토픽에서 결제 요청 이벤트 소비
  5. 결제 성공
     * 결제 토픽에 결제 성공 이벤트 생성
  6. 티켓/호텔/예약 서비스
     * 결제 성공 이벤트 소비
     * 예약 성공으로 변경
### 5.6.2 오케스트레이션 방식
* 오케스트레이터는 카프카 토픽을 통해 각 서비스와 통신
* 호텔 예약 서비스 예시
  1. 오케스트레이터가 예약 토픽에 티켓 요청 이벤트 생성
  2. 티켓 서비스가 티켓요청 이벤트 소비, 항공권 예약
  3. 티켓 서비스가 응답 토픽에 티켓 결제 대기 이벤트 생성
  4. 오케스트레이터가 티켓 결제 대기 이벤트 생성
  5. 오케스트레이터가 호텔 토픽에 호텔 예약 요청 이벤트 생성
  6. 호텔서비스가 호텔 예약 요청 이벤트 소비, 호텔 객실 예약
  7. 호텔서비스가 응답 토픽에 객실결제대기 이벤트 생성
  8. 오케스트레이터가 객실결제 대기 이벤트 소비
  9. 오케스트레이터가 결제 토픽에 결제 요청 이벤트 생성
  10. 결제 서비스가 결제 요청 이벤트 소비
  11. 결제 서비스가 결제 처리, 응답 토픽에 결제확인 이벤트 생성
  12. 오케스트레이터가 결제 확인 이벤트 소비
  13. 오케스트레이터가 예약 토픽에 결제 확인 이벤트 생성
  14. 티켓서비스가 결제 확인 이벤트 소비, 예약 상태를 변경
  15. 티켓 서비스가 응답 토픽에 티켓 확인 이벤트 생성
  16. 오케스트레이터가 응답 토픽에 티켓 확인 이벤트 소비
  17. 오케스트레이터가 호텔 토픽에 결제 확인 이벤트 생성
  18. 호텔 서비스가 결제 확인 이벤트 소비, 예약 상태를 변경
  19. 호텔 서비스가 응답 토픽에 호텔객실확인 이베느 생성
  20. 오케스트레이터가 호텔 객실 이벤트 소비, 사용자에게 성공 응답


