# 15장 - 에어비앤비 설계

## 15.1 요구사항

- 에어비앤비의 특성
  - 예약 앱: 게스트가 유한한 아이템(숙소)에 대해 예약을 하고, 호스트가 이를 제공
  - 마켓플레이스 앱: 상품/서비스를 판매하는 사람(호스트)과 구매하는 사람(게스트)를 연결
  - 결제 및 운영: 내부 직원(Ops)이 고객 지원, 분쟁 조정, 사기 모니터링 등을 담당
- 사용자별 주요 기능
  - 호스트
    - 등록 및 수정: 숙소 추가/수정/삭제, 사진 업로드, 가격 설정
      - 숙소별 최소/최대 예약 기간 설정
      - 지역별 규정 준수 (예: 샌프란시스코 연간 90일 제한)
      - Ops 승인이 필요한 경우 존재
    - 예약 관리: 예약 요청 수락/거절, 취소 처리
      - 게스트의 평점과 리뷰 확인 후 승인
      - 자동 승인 기준 설정 (높은 평점의 게스트 등)
    - 커뮤니케이션: 게스트와 앱 내 메시징, Ops와의 소통
    - 리뷰 및 결제: 게스트 평점/리뷰 작성, 수수료 제외한 결제 수령
    - 분석: 수익, 평점, 리뷰 내용의 시간대별 분석
  - 게스트
    - 검색 및 조회: 숙소 검색, 상세 정보 확인
    - 예약: 예약 요청 및 결제, 예약 상태 확인
    - 커뮤니케이션: 호스트와 메시징, Ops와 소통
    - 리뷰: 숙소 평점/리뷰 작성 및 호스트 리뷰 확인
  - Ops (운영진)
    - 리스팅 검토: 부적절한 숙소 검토 및 제거
    - 고객 지원: 분쟁 조정, 대체 숙소 제안, 환불 처리
- 기능적 요구사항 (간소화)
  - 호스트는 방을 등록 가능 (1인용, 도시와 가격 정보만 포함)
  - 호스트는 방당 최대 10장 사진과 25MB 비디오 업로드 가능
  - 게스트는 도시, 체크인/체크아웃 날짜로 방 검색 가능
  - 게스트는 호스트 승인 없이 예약 가능
  - 호스트/게스트는 예약 시작 전 언제든 취소 가능
  - 게스트는 특정 날짜에 하나의 방만 예약 가능
  - 중복 예약 금지
- 범위 제외 항목
  - 정확한 주소 (도시명만 사용)
  - 편의시설 세부사항 (전용/공용 화장실 등)
  - 가격 추천 기능
  - 청소비, 세금 등 추가 비용
  - 결제/환불 시스템
  - 고객 지원 상세 프로세스
  - 사용자 리뷰 시스템
- 비기능적 요구사항
  - 확장성: 10억 개 방, 일일 1억 예약
  - 일관성: 예약 가용성에 대한 강한 일관성, 기타 정보는 최종 일관성 허용
  - 고가용성: 금전적 손실 방지를 위한 높은 가용성
  - 성능: P99 몇 초 정도 허용
  - 보안: 사용자 인증 필요, 데이터 프라이버시 보장

## 15.2 설계 결정
- 15.2.1 복제
  - 지역별 파티셔닝: Craigslist와 유사하게 도시별로 데이터 센터 할당
  - 단일 리더 복제: 쓰기 성능이 중요하지 않으므로 단일 리더 사용
  - 지역별 분산: 읽기 지연시간 최소화를 위해 보조 리더와 팔로워를 지리적으로 분산
  - 메타데이터 서비스: 도시별 리더/팔로워 호스트 IP 매핑 정보 관리
  - CDN 사용: 방 사진/비디오와 정적 콘텐츠 저장
  - 캐시 미사용 결정: 인기 있는 방은 빨리 예약되어 검색에서 사라지므로 캐시 효과 제한적
- 15.2.2 방 가용성 데이터 모델 
  - 옵션 1: (room_id, date, guest_id) 테이블
    - 장점: 개념적으로 간단
    - 단점: 긴 예약 기간 시 많은 행 생성 (1월 예약 시 31개 행)
  - 옵션 2: (room_id, guest_id, check_in, check_out) 테이블
    - 장점: 더 컴팩트한 저장
    - 단점: 겹치는 날짜 확인을 위한 복잡한 알고리즘 필요
    - 구현 선택: 데이터베이스 쿼리 vs 백엔드 로직
- 15.2.3 겹치는 예약 자리
  - 첫 번째 사용자 우선: 동시 예약 요청 시 먼저 도착한 요청 승인
  - 사용자 안내: 다른 사용자들에게 방이 더 이상 사용 불가함을 알리고 대체 방 안내
- 15.2.4 검색 결과 무작위화
  - 목적: 중복 예약 발생 빈도 감소
  - 트레이드오프: 개인화 추천 시스템과 충돌 가능성
- 15.2.5 예약 과정 중 방 잠금
  - 잠금 메커니즘: 상세 정보 확인 시 몇 분간 해당 날짜 잠금
  - 검색 제외: 잠금된 방은 다른 사용자 검색 결과에서 제외
  - 트레이드오프: 중복 예약 방지 vs 일부 예약 기회 손실
  - 호텔과의 차이: 호텔은 오버부킹 후 업그레이드 가능하지만 에어비앤비는 불가

## 15.3 고수준 아키텍처
- 서비스 구성
  - 예약 서비스 (Booking Service)
    - 역할: 게스트의 예약 처리
    - 중요도: 직접적인 수익원으로 가장 엄격한 비기능 요구사항
    - 특성: 고가용성과 저지연이 중요, 강한 일관성보다 가용성 우선
  - 목록 서비스 (Listing Service)
    - 역할: 호스트의 숙소 생성 및 관리
    - 중요도: 중요하지만 예약 서비스보다는 덜 중요
    - 분리 이유: 다른 기능/비기능 요구사항으로 인한 리소스 분리
  - 가용성 서비스 (Availability Service)
    - 역할: 숙소 가용성 추적 및 관리
    - 사용자: 예약 서비스와 리스팅 서비스 모두 사용
    - 요구사항: 예약 서비스와 동일한 수준의 가용성과 지연시간
    - 특성: 읽기 확장성 중요, 쓰기는 상대적으로 적음
  - 승인 서비스 (Approval Service)
    - 역할: 새 리스팅이나 특정 업데이트의 Ops 승인 처리
    - 명명: "리뷰 서비스"보다 명확한 "승인 서비스" 사용
  - 추천 서비스 (Recommender Service)
    - 역할: 게스트에게 개인화된 숙소 추천
    - 성격: 내부 광고 서비스와 유사
  - 규정 서비스 (Regulations Service)
    - 역할: 지역별 규제 정보 제공 API
    - 목적: 리스팅/예약 서비스가 지역 규제를 준수할 수 있도록 지원
    - 개발: 별도 팀이 규제 전문 지식을 담당
  - 아키텍처 다이어그램
    ```
    API Gateway → [Booking Service] → Availability Service
               → [Listing Service] → CDN
               → [Recommender Service] → Elasticsearch
                                   → Payment Service
                                   → Metadata Service
    ```
## 15.4 기능별 분할
- 지역별 파티셔닝: Craigslist와 유사한 방식으로 지역별 데이터 센터에 숙소 배치
- 각 사용자를 해당 도시를 서비스하는 데이터 센터로 라우팅
- 다중 데이터 센터 배포 및 지역별 라우팅 구조

## 15.5 목록 생성 또는 업데이트
- 규정 정보 획득
  1. 위치 기반 요청: 호스트가 새 숙소 등록 버튼 클릭 시 위치 정보 전송
  2. 규정 서비스 조회: 리스팅 서비스가 해당 위치의 규정 정보 요청
  3. UI 조정: 클라이언트가 규정에 맞춰 UI 조정 (예: 최소 14일 규칙 시 에러 표시)
- 숙소 등록 요청
  1. 검증: 요청 본문 유효성 확인
  2. 데이터베이스 저장: Listing 테이블에 저장 (Approved 컬럼으로 승인 상태 관리)
  3. 승인 요청: 필요시 승인 서비스에 POST 요청
  4. 응답: 클라이언트에 200 응답
- 분산 트랜잭션 처리
  - CDC (Change Data Capture) 사용: SQL 토픽과 승인 토픽을 통한 병렬 처리
  - 멱등성: INSERT IGNORE를 사용한 중복 쓰기 방지
  - 트랜잭션 로그 테일링: 안정적인 분산 트랜잭션 보장
- 실제 구현 고려사항
  - 다중 요청 구조: 실제로는 여러 단계로 나누어진 폼 제출
  - 업데이트 허용: 승인 대기 중에도 호스트가 추가 수정 가능
  - 알림 시스템: 배치 ETL 작업을 통한 호스트/Ops 알림

## 15.6 승인 서비스
- 아키텍처
  - 단순한 구조: 낮은 트래픽의 내부 애플리케이션
  - 구성요소: 클라이언트 웹 앱 + 백엔드 서비스 + SQL 서비스
  - 수동 승인: 모든 요청에 대해 수동 승인/거절 (자동화 없음)
- 데이터베이스 스키마 (listing_request 테이블)
  - `id`: 기본키
  - `listing_id`: 리스팅 서비스의 숙소 ID
  - `created_at`: 요청 생성/수정 타임스탬프
  - `listing_hash`: 검토 중 변경 방지를 위한 해시
  - `status`: "none", "assigned", "reviewed" 상태
  - `last_accessed`: 마지막 접근 시간
  - `review_code`: 승인/거절 사유 코드
  - `reviewer_id`: 담당 Ops 직원 ID
  - `review_submitted_at`: 검토 제출 시간
  - `review_notes`: 검토 메모
- 작업 할당 시스템
  - SQL 트랜잭션을 통한 작업 할당:
    1. 기존 할당 작업 확인
    2. 미할당 작업 중 가장 오래된 것 선택
    3. 상태를 "assigned"로 변경하고 reviewer_id 설정
- 승인/거절 처리
  - 동기식 처리
    1. listing_request 테이블 업데이트: 상태, 검토 코드, 제출 시간 등
    2. 리스팅 서비스 업데이트: PUT 요청으로 승인 상태 변경
    3. 예약 서비스 통지: 승인된 숙소를 게스트에게 표시
    4. 알림 서비스: 호스트에게 승인/거절 알림
    5. 멱등성 보장: 실패 시 재시도 가능하도록 설계
  - 비동기식 처리 (CDC 사용)
    1. Kafka 큐에 발행: 승인 요청을 큐에 넣고 즉시 200 응답
    2. 소비자 처리: 큐에서 이벤트를 소비하여 각 서비스 업데이트
    3. 장점: 낮은 지연시간, 높은 처리량
    4. 알림 조정: 모든 서비스 업데이트 완료 후 알림 전송
- 자동화 및 머신러닝
  - 규칙 기반: SQL Rules 테이블에 자동 승인/거절 규칙 저장
  - 머신러닝: 훈련된 모델을 통한 자동 판정
  - 결합 방식: 규칙과 ML 모델 결과를 조합하여 최종 판정

## 15.7 예약 서비스
- 예약 프로세스
  1. 검색: 도시, 체크인/체크아웃 날짜로 사용 가능한 숙소 조회
  2. 필터링: 가격 및 기타 조건으로 결과 필터링
  3. 상세 조회: 고해상도 사진/비디오 포함 상세 정보 확인
  4. 예약 요청: 예약 요청 제출 및 확인/에러 응답 수신
  5. 결제: 확인 시 결제 페이지로 이동
  6. 취소: 사용자가 마음 변경 시 취소 요청
- 아키텍처 구성
  - 백엔드 서비스: 모든 쿼리 처리
  - Elasticsearch 서비스: 검색 및 필터링
  - SQL 서비스: 예약 상세 정보 CRUD
  - 가용성 서비스: 예약 요청 처리
  - CDN: 사진/비디오 다운로드
- 확장성 분석
  - 추정치: 특정 도시 내 최대 100만 개 숙소
  - 트래픽: 일일 1,000만 요청 (피크 시간 기준 3,000 QPS)
  - 처리 능력: 단일 또는 소수 호스트로 처리 가능
  - 아키텍처: 더 큰 트래픽도 처리 가능하도록 설계
- 데이터베이스 스키마 (Booking 테이블)
    - `id`: 예약 기본키 ID
    - `listing_id`: 리스팅 서비스의 숙소 ID
    - `guest_id`: 예약한 게스트 ID
    - `check_in`: 체크인 날짜
    - `check_out`: 체크아웃 날짜
    - `timestamp`: 행 생성/수정 시간
- 쓰기 작업
  1. 예약 요청: 클라이언트 요청
  2. 승인 서비스: 숙소 상세 정보 업데이트 (승인된 숙소)
  3. 취소 요청: 결제 실패 등으로 인한 예약 취소
- 분산 트랜잭션
  - 필요성: SQL 서비스와 Elasticsearch 서비스 간 일관성
  - 구현: 분산 트랜잭션 기법 사용
  - 예약 처리: 예약 서비스와 가용성 서비스 간 분산 트랜잭션
- 서비스 분리 고려사항
  많은 게스트가 여러 숙소를 검색/조회한 후 소수만 예약하므로:
  - 검색/조회 서비스: 높은 트래픽, 더 많은 리소스
  - 예약 처리 서비스: 낮은 트래픽, 적은 리소스
  - 독립적 확장: 각각의 특성에 맞춘 별도 확장

## 15.8 가용성 서비스
- 목적 및 문제점 방지
  - 중복 예약 방지: 동일한 방의 중복 예약 차단
  - 가시성 보장: 게스트 예약이 호스트에게 정확히 표시
  - 규칙 준수: 호스트가 설정한 사용 불가 날짜 존중
  - 고객 지원: 불량한 경험으로 인한 고객 불만 최소화
- API 엔드포인트
  - GET: 위치, 숙소 유형, 날짜 조건으로 사용 가능한 숙소 조회
  - POST: 특정 날짜 범위를 몇 분간 잠금
  - PUT/POST: 예약 생성/수정
  - DELETE: 예약 취소
- 15.8.3 아키텍처
  - 백엔드 서비스: SQL 서비스에 요청하는 단일 서비스
  - SQL 서비스: 리더-팔로워 아키텍처 사용
- 15.8.4 데이터베이스 스키마 (availability 테이블)
  - `listing_id`: 리스팅 서비스의 숙소 ID
  - `date`: 가용성 날짜
  - `booking_id`: 예약 서비스의 예약 ID
  - `available`: "available", "locked", "booked" 상태
  - `timestamp`: 행 생성/수정 시간
  - 기본키 없음: 복합 인덱스 사용
- 잠금 메커니즘
  - 클라이언트 타이머: 6분 타이머 표시 (백엔드보다 약간 길게)
  - 시계 동기화: 클라이언트와 백엔드 시계 불일치 고려
  - SQL 행 잠금: 중복 예약 완전 방지를 위한 배타적 잠금 사용
  - 트랜잭션: SELECT → INSERT/UPDATE 순서로 원자적 처리
- 일관성 트레이드오프
  - 검색 결과: 팔로워에서 읽으므로 사용 불가한 숙소 포함 가능
  - 409 응답: 사용 불가한 숙소 예약 시도 시 Conflict 응답
  - 사용자 경험: 다른 사용자가 먼저 예약할 가능성을 사용자가 이해
  - 모니터링: 과도한 409 응답 발생 시 알림
- 저장소 요구사항
  - 계산: 100만 숙소 × 180일 × 40바이트 = 7.2GB
  - 단일 호스트: 충분히 작은 크기로 단일 호스트 처리 가능
  - 데이터 정리: 오래된 데이터 수동 삭제로 공간 확보
- 대안 스키마
  예약 테이블과 유사한 구조:
  - `(room_id, guest_id, check_in, check_out, status)` 형태
  - 날짜 겹침 확인 알고리즘 필요 (코딩 인터뷰 문제로 적합)

## 15.9 로깅, 모니터링, 경보
- 기본 모니터링
  - CPU, 메모리, 디스크 사용량
  - Redis, Elasticsearch 디스크 사용량
  - 일반적인 시스템 리소스 모니터링
- 이상 감지
  - 예약률 이상: 비정상적인 예약/숙소 등록/취소율
  - 수동/자동 플래깅: 부정 행위로 의심되는 높은 신고율
  - 패턴 분석: 평상시와 다른 비정상적 활동 패턴
- 사용자 스토리 모니터링
  - 완료율 추적: 호스트 숙소 등록 과정, 게스트 예약 과정의 완료 vs 미완료 비율
  - 퍼널 전환율: 비정상적으로 높은 중도 포기율에 대한 경보
  - 종단간 모니터링: 전체 사용자 여정에 대한 성공률 추적
- 비즈니스 특화 모니터링
  - 예약 실패율: 예약 요청 중 실패하는 비율
  - 호스트-게스트 커뮤니케이션: 취소로 이어지는 문제 상황
  - 지역별 성과: 특정 지역의 예약률 이상

## 15.10 기타 논의 가능한 주제들
- 규정 처리
  - 전용 규정 서비스: 표준 API를 통한 규정 정보 제공
  - 유연한 설계: 변화하는 규정에 쉽게 적응할 수 있는 아키텍처
  - 리소스 최적화: 규정 변경 시마다 재설계/구현/마이그레이션 비용 최소화